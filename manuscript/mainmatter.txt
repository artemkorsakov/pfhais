{mainmatter}

# Our use case #

For better understanding we will implement a small use case in both impure and pure way. The following section will outline the specification.

# Service specification

First we need to specify the exact scope and API of our service. We'll design a service with a minimal API to keep things simple. It shall fulfil the following requirements.

The service shall provide HTTP API endpoints for:

1. the creation of a product data type identified by a unique id
2. adding translations for a product name by language code and unique id
3. returning the existing translations for a product
4. returning a list of all existing products with their translations

## Data model

We will keep the model very simple to avoid going overboard with the implementation.

1. A language code shall be defined by the ISO 639-1 (e.g. a two letter code).
2. A translation shall contain a language code and a product name (non-empty string).
3. A product shall contain a unique id (UUID version 4) and a list of translations.

## Database

The data will be stored in a relational database (RDBMS). Therefore we need to define the tables and relations within the database.

### The products table

The table `products` must contain only the unique id which is also the primary key.

### The names table

The table `names` must contain a column for the product id, one for the language code and one for the name. Its primary key is the combination of the product id and the language code. All columns must not be null. The relation to the products is realised by a foreign key constraint to the `products` table via the product id.

## HTTP API

The HTTP API shall provide the following endpoints on the given paths:

| Path              | HTTP method | Function                              |
|-------------------|-------------|---------------------------------------|
| `/products`       | POST        | Create a product.                     |
| `/products`       | GET         | Get all products and translations.    |
| `/product/{UUID}` | PUT         | Add translations.                     |
| `/product/{UUID}` | GET         | Get all translations for the product. |

The data shall be encoded in JSON using the following specification:

{caption: "JSON for a translation"}
```json
{
  "lang": "ISO-639-1 Code",
  "name": "A non empty string."
}
```

{caption: "JSON for a product"}
```json
{
  "id": "The-UUID-of-the-product",
  "names": [
    // A list of translations.
  ]
}
```

This should be enough to get us started.

# The state of the art #

Within the Scala ecosystem the Akka-HTTP library is a popular choice for implementing server side backends for HTTP APIs. Another quite popular option is the Play framework but using a full blown web framework to just provide a thin API is overkill in most cases. As most services need a database the Slick library is another popular choice which completes the picture.

However while all mentioned libraries are battle tested and proven they still have problems.

# Problems

In the domain of functional programming we want referential transparency which we will define in the following way:

I> An expression `e` is referential transparent if we can in any given program replace any occurances of `e` with the result of the evaluation of `e` without changing the behaviour of the program.

Building on that we need pure functions which are

1. only dependent on their input
2. have no side effects

This means in turn that our functions will be referential transparent.

**But**, the mentioned libraries are built upon the `Future` from Scala which uses eager evaluation and breaks referential transparency. Let's look at an example.

{caption: "Future example 1"}
```scala
import scala.concurrent.Future
import scala.concurrent.ExecutionContext.Implicits.global

for {
  _ <- Future { println("Hi there!") }
  _ <- Future { println("Hi there!") }
} yield ()
```

The code above will print the text `Hi there!` two times. But how about the following one?

{caption: "Future example 2"}
```scala
import scala.concurrent.Future
import scala.concurrent.ExecutionContext.Implicits.global

val printF = Future { println("Hi there!") }

for {
  _ <- printF
  _ <- printF
} yield ()
```

Instead of printing the text two times it will print it only once even when there is no usage of `printF` at all (try omitting the for comprehension). This means that `Future` breaks referential transparency!

Q> So `Future` makes it harder (sometimes impossible) to reason about our code and also raises the bar for testability. What can we do?

# Maybe there is another way #

If we want referential transparency, we must push the side effects to the boundaries of our system (program) which can be done by using lazy evaluation. Let's repeat the previous example in a different way.

{caption: "IO example 1"}
```scala
import cats.effect.IO
import cats.implicits._

val effect = for {
  _ <- IO(println("Hi there!"))
  _ <- IO(println("Hi there!"))
} yield ()
```

The above code will produce no output. Only if we evaluate the variable `effect` which is of type `IO[Unit]` will the output be generated (try `effect.unsafeRunSync` in the REPL). Also the second approach works like expected.

{caption: "IO example 2"}
```scala
import cats.effect.IO
import cats.implicits._

val printF = IO(println("Hi there!"))

val effect = for {
  _ <- printF
  _ <- printF
} yield ()
```

Q> What have we gained?

Suddenly we can much more easily reason about our code! And why is that? Well we don't have unexpected side effects caused by code running even when it doesn't need to. This is a sneak peak how pure code looks like. Now we only need to implement pure libraries for our use, or do we?

Luckily for us meanwhile there are several pure options available in the Scala ecosystem. We will stick to the Cats family of libraries namely http4s and Doobie as replacements for Akka-HTTP and Slick. They build upon the Cats Effect library which is an implementation of an IO monad for Scala. Some other options exist but we'll stick to the one from Cats.

To be able to contrast both ways of implementing a service we will first implement it using Akka-HTTP and Slick and will then migrate to http4s and Doobie.

# Impure implementation

We'll be using the following libraries for the impure version of the service:

1. Akka (including Akka-HTTP and Akka-Streams)
2. Slick (as database layer)
3. Flyway for database migrations (or evolutions)
4. Circe for JSON codecs and akka-http-json as wrapper
5. Refined for using refined types
6. the PostgreSQL JDBC driver

I'll spare you the sbt setup as you can look that up in the code repository (i.e. the `impure` folder in the book repo).

## Models

First we'll implement our models which are simple and straightforward. At first we need a class to store our translations or better a single translation.

```scala
final case class Translation(lang: String, name: String)
```

Q> So what is wrong with that approach?

Technically it is okay but we have a bad feeling about it. Using `Option[String]` is of no use because both fields have to be set. But a `String` can always be `null` and contain a lot of unexpected stuff (literally anything).

I> This is the moment when refined types come to you rescue!

So let us define some refined types which we can use later on. At first we need a language code which obeys the restrictions of ISO-639-1 and we need a stronger definition for a product name. For the former we use a regular expression and for the latter we simply expect a string which is not empty.

{caption: "Refined types for models"}
```scala
type LanguageCode = String Refined MatchesRegex[W.`"^[a-z]{2}$"`.T]
type ProductName = String Refined NonEmpty
```

Now we can give our translation model another try.

{caption: "Translation model using refined types"}
```scala
final case class Translation(lang: LanguageCode, name: ProductName)
```

Much better and while we're at it we can also write the JSON codecs using the refined module of the Circe library. We put them into the companion object of the model.

```scala
object Translation {
  implicit val decode: Decoder[Translation] =
    Decoder.forProduct2("lang", "name")(Translation.apply)

  implicit val encode: Encoder[Translation] =
    Encoder.forProduct2("lang", "name")(t => (t.lang, t.name))
}
```

Now onwards to the product model. Because we already know of refined types we can use them from start here.

```scala
type ProductId = String Refined Uuid
final case class Product(id: ProductId, names: List[Translation])
```

Q> Now what is wrong about this?

If we look closely we realise that a `List` maybe empty. Which is valid for the list but not for our product because we need at least one entry. Luckily for us the Cats library has us covered with the `NonEmptyList` data type. Including the JSON codecs this leads us to our final implementation.
Last but not least we really should be using the existing `UUID` data type instead of rolling our own refined string version - even when it is cool. ;-)

{caption: "Product model using UUID type and NeL"}
```scala
type ProductId = java.util.UUID
final case class Product(id: ProductId, names: NonEmptyList[Translation])

object Product {
  implicit val decode: Decoder[Product] =
    Decoder.forProduct2("id", "names")(Product.apply)

  implicit val encode: Encoder[Product] =
    Encoder.forProduct2("id", "names")(p => (p.id, p.names))
}
```

We kept the type name `ProductId` by using a type alias. This is convenient but remember that a type alias does not add extra type safety (e.g.Â `type Foo = String` will be a `String`).

Q> Why do I have a bad feeling about this?

Well, maybe because a list may contain duplicate entries but the database will surely not because of unique constraints! So, let's switch to a `NonEmptySet` which is also provided by Cats.

{caption: "Product model using UUID and NeS"}
```scala
type ProductId = java.util.UUID
final case class Product(id: ProductId, names: NonEmptySet[Translation])
```

Now we have the models covered and can move on to the database layer.

## Database layer

The database layer should provide a programmatic access to the database but also should it manage changes in the database. The latter one is called migrations or evolutions. From the available options we chose Flyway as the tool to manage our database schema.

### Migrations

Flyway uses raw SQL scripts which have to be put into a certain location being `/db/migration` (under the `resources` folder) in our case. Also the files have to be named like `VXX__some_name.sql` (`XX` being a number) starting with `V1`. Please note that there are two underscores between the version prefix and the rest of the name! Because our database schema is very simply we're done quickly:

{caption: "Flyway migration for creating the database"}
```sql
CREATE TABLE "products" (
  "id" UUID NOT NULL,
  CONSTRAINT "products_pk" PRIMARY KEY ("id")
);

CREATE TABLE "names" (
  "product_id" UUID       NOT NULL,
  "lang_code"  VARCHAR(2) NOT NULL,
  "name"       TEXT       NOT NULL,
  CONSTRAINT "names_pk" 
    PRIMARY KEY ("product_id", "lang_code"),
  CONSTRAINT "names_product_id_fk" 
    FOREIGN KEY ("product_id") 
    REFERENCES "products" ("id") 
    ON DELETE CASCADE ON UPDATE CASCADE
);
```

In the code you'll see that we additionally set comments which are omitted from the code snippet above. This might be overkill here but it is a very handy feature to have and I advice you to use it for more complicated database schemas. Because the right comment (read *information*) in the right place might save a lot of time when trying to understand things.

Next we move on to the programmatic part which at first needs a configuration of our database connection. With Slick you have a multitude of options but we'll use the "Typesafe Config"[^11] approach.

{caption: "Database configuration in application.conf"}
```text
database {
  profile = "slick.jdbc.PostgresProfile$"
  db {
    connectionPool = "HikariCP"
    dataSourceClass = "org.postgresql.ds.PGSimpleDataSource"
    properties {
      serverName = "localhost"
      portNumber = "5432"
      databaseName = "impure"
      user = "impure"
      password = "secret"
    }
    numThreads = 10
  }
}
```

After we have this in place we can run the migrations via the API of Flyway. For this we have to load the configuration (we do it by creating an actor system), extract the needed information and create a JDBC url and use that with username and password to obtain a Flyway instance. On that one we simply call the method `migrate()` which will do the right thing. Basically it will check if the schema exists and decide to either create it, apply pending migrations or simply do nothing. The method will return the number of applied migrations.

{caption: "Apply database migrations via Flyway"}
```scala
implicit val system: ActorSystem    = ActorSystem()
implicit val mat: ActorMaterializer = ActorMaterializer()
implicit val ec: ExecutionContext   = system.dispatcher

val url = "jdbc:postgresql://" +
system.settings.config.getString("database.db.properties.serverName") +
":" + system.settings.config.getString("database.db.properties.portNumber") +
"/" + system.settings.config.getString("database.db.properties.databaseName")
val user = system.settings.config.getString("database.db.properties.user")
val pass = system.settings.config.getString("database.db.properties.password")
val flyway = Flyway.configure().dataSource(url, user, pass).load()
val _ = flyway.migrate()
```

Let us continue to dive into the Slick table definitions.

### Slick tables

Slick offers several options for approaching the database. For our example we will be using the lifted embedding but if needed Slick also provides the ability to perform plain SQL queries.
For the lifted embedding we have to define out tables in a way Slick can understand. While this can be tricky under certain circumstances our simple model is straightforward to implement.

{caption: "Slick product table definition"}
```scala
final class Products(tag: Tag) extends Table[(UUID)](tag, "products") {
  def id = column[UUID]("id", O.PrimaryKey)

  def * = (id)
}
val productsTable = TableQuery[Products]
```

As you can see above we're using simple data types (not the refined ones) to have a more easy Slick implementation. However we can also use refined types for the price of using either the slick-refined library or writing custom column mappers.
Next we'll implement the table for the translations which will also need some constraints.

{caption: "Slick translations table definition"}
```scala
final class Names(tag: Tag) extends Table[(UUID, String, String)](tag, "names") {
  def productId = column[UUID]("product_id")
  def langCode  = column[String]("lang_code")
  def name      = column[String]("name")

  def pk = primaryKey("names_pk", (productId, langCode))
  def productFk =
    foreignKey("names_product_id_fk", productId, productsTable)(
      _.id,
      onDelete = ForeignKeyAction.Cascade,
      onUpdate = ForeignKeyAction.Cascade
    )

  def * = (productId, langCode, name)
}
val namesTable = TableQuery[Names]
```

As you can see the definition of constraints is also pretty simple. Now our repository needs some functions for a more convenient access to the data.

{caption: "Slick repository functions"}
```scala
def loadProduct(id: ProductId): Future[Seq[(UUID, String, String)]] = {
  val program = for {
    (p, ns) <- productsTable
      .filter(_.id === id)
      .join(namesTable)
      .on(_.id === _.productId)
  } yield (p.id, ns.langCode, ns.name)
  dbConfig.db.run(program.result)
}

def loadProducts(): DatabasePublisher[(UUID, String, String)] = {
  val program = for {
    (p, ns) <- productsTable.join(namesTable)
                 .on(_.id === _.productId).sortBy(_._1.id)
  } yield (p.id, ns.langCode, ns.name)
  dbConfig.db.stream(program.result)
}

def saveProduct(p: Product): Future[List[Int]] = {
  val cp      = productsTable += (p.id)
  val program = DBIO.sequence(
    cp :: saveTranslations(p).toList
  ).transactionally
  dbConfig.db.run(program)
}

def updateProduct(p: Product): Future[List[Int]] = {
  val program = namesTable
    .filter(_.productId === p.id)
    .delete
    .andThen(DBIO.sequence(saveTranslations(p).toList))
    .transactionally
  dbConfig.db.run(program)
}

protected def saveTranslations(p: Product): NonEmptyList[DBIO[Int]] = {
  val save = saveTranslation(p.id)(_)
  p.names.toNonEmptyList.map(t => save(t))
}

/**
  * Create a query to insert or update a given translation in the database.
  *
  * @param id The unique ID of the product.
  * @param t  The translation to be saved.
  * @return A composable sql query for Slick.
  */
protected def saveTranslation(id: ProductId)(t: Translation): DBIO[Int] =
  namesTable.insertOrUpdate((id, t.lang, t.name))
```

The last two functions are helpers to enable us to create a load queries which we can compose. They are used in the `saveProduct` and `updateProduct` functions to create a list of queries that are executed as bulk while the call to `transactionally` ensures that they will run within a transaction. When updating a product we first delete all existing translations to allow the removal of existing translations via an update. To be able to do so we use the `andThen` helper from Slick.
The `loadProduct` function simply returns a list of database rows from the needed join. Therefore we need a function which builds a `Product` type out of that.

{caption: "Helper function to create a Product"}
```scala
def fromDatabase(rows: Seq[(UUID, String, String)]): Option[Product] = {
  val po = for {
    (id, c, n) <- rows.headOption
    t          <- Translation.fromUnsafe(c)(n)
    p          <- Product(
                    id = id,
                    names = NonEmptySet.one[Translation](t)
                  ).some
  } yield p
  po.map(
    p =>
      rows.drop(1).foldLeft(p) { (a, cols) =>
        val (id, c, n) = cols
        Translation.fromUnsafe(c)(n).fold(a)(t =>
          a.copy(names = a.names.add(t))
        )
    }
  )
}
```

But oh no! The compiler refuses to build it:

{caption: "Missing cats.Order"}
```text
[error] .../impure/models/Product.scala:45:74:
  could not find implicit value for parameter A: 
    cats.kernel.Order[com.wegtam.books.pfhais.impure.models.Translation]
[error] p <- Product(id = id, names = NonEmptySet.one[Translation](t)).some
[error]                                                            ^
```

It seems we have to provide an instance of `Order` for our `Translation` model to make Cats happy. So we have think of an ordering for our model. A simple approach would be to simply order by the language code. Let's try this:

{caption: "Providing Order for LanguageCode"}
```scala
import cats._
import cats.syntax.order._

implicit val orderLanguageCode: Order[LanguageCode] = 
  new Order[LanguageCode] {
    def compare(x: LanguageCode, y: LanguageCode): Int =
      x.value.compare(y.value)
  }
```

I> Please note that you will need to import either the `syntax.order._` package or the `implicits` package from Cats.

You might have noticed the explicit call to `.value` to get the underlying string instance of our refined type. This is needed because the other option (using `x.compare(y)`) will compile but bless you with stack overflow errors. The reason is probably that the latter is compiled into code calling `OrderOps#compare` which is recursive.

{caption: "Providing Order for Translation"}
```scala
import cats._
import cats.syntax.order._

implicit val order: Order[Translation] =
  new Order[Translation] {
    def compare(x: Translation, y: Translation): Int =
      x.lang.compare(y.lang)
  }
```

So far we should have everything in place to make use of our database. Now we need to wire it all together.

## Akka-HTTP routes

Defining the routes is pretty simple if you're used to the Akka-HTTP routing DSL syntax.

{caption: "Basic routes with Akka-HTTP"}
```scala
val route = path("product" / JavaUUID) { id: ProductId =>
  get {
    ???
  } ~ put {
    ???
  }
} ~ path("products") {
  get {
    ???
  } ~
  post {
    ???
  }
}
```

We will fill in the details later on. But now for starting the actual server to make use of our routes.

{caption: "Starting an Akka-HTTP server"}
```scala
val host       = system.settings.config.getString("api.host")
val port       = system.settings.config.getInt("api.port")
val srv        = Http().bindAndHandle(route, host, port)
val pressEnter = StdIn.readLine()
srv.flatMap(_.unbind()).onComplete(_ => system.terminate())
```

The code will fire up a server using the defined routes and hostname and port from the configuration to start a server. It will run until you press enter and then terminate. Let us now visit the code for each routing endpoint. We will start with the one for returning a single product.

{caption: "Returning a single product"}
```scala
path("product" / JavaUUID) { id: ProductId =>
  get {
    complete {
      for {
        rows <- repo.loadProduct(id)
        prod <- Future { Product.fromDatabase(rows) }
      } yield prod
    }
  }
}
```

We load the raw product data from the repository and convert it into a proper product model. But to make the types align we have to wrap the second call in a `Future` otherwise we would get a compiler error. We don't need to marshal the response because we are using the akka-http-json library which provides for example an `ErrorAccumulatingCirceSupport` import that handles this. Unless of course you do not have circe codecs defined for your types.

{caption: "Updating a single product"}
```scala
val route = path("product" / JavaUUID) { id: ProductId =>
  put {
    entity(as[Product]) { p =>
      complete {
        repo.updateProduct(p)
      }
    }
  }
}
```

The route for updating a product is also very simple. We're extracting the product entity via the `entity(as[T])` directive from the request body and simply give it to the appropriate repository function. Now onwards to creating a new product.

{caption: "Creating a product"}
```scala
path("products") {
  post {
    entity(as[Product]) { p =>
      complete {
        repo.saveProduct(p)
      }
    }
  }
}
```

As you can see the function is basically the same except that we're calling a different function from the repository. Last but not least let us take a look at the return all products endpoint.

{caption: "Return all products"}
```scala
path("products") {
  get {
    complete {
      val products = for {
        rows <- repo.loadProducts()
        ps <- Future {
          rows.toList.groupBy(_._1).map {
            case (_, cols) => Product.fromDatabase(cols)
          }
        }
      } yield ps
      products.map(_.toList.flatten)
    }
  }
}
```

This looks more complicated that the other endpoints. So what exactly are we doing here?
Well first we load the raw product data from the repository. Afterwards we convert it into the proper data model or to be more exact into a list of product entities.

Q> What is wrong with that approach?

The first thing that comes to mind is that we're performing operations in memory. This is not different from the last time when we converted the data for a single product. Now however we're talking about all products which may be a lot of data. Another obvious point is that we get a list of `Option[Product]` which we explicitly flatten at the end.

Q> So, how can we do better?

Maybe we should consider streaming the results. But we still have to group and combine the rows which belong to a single product into a product entity. Can we achieve that with streaming? Well, let's look at our data flow.
We receive a list of 3 columns from the database in the following format: `product id, language code, name`. The tricky part being that multiple rows (list entries) can belong to the same product recognizable by the same value for the first column `product id`. At first we should simplify our problem by ensuring that the list will be sorted by the `product id`. This is done by adjusting the function `loadProducts` in the repository.

{caption: "Sort the returned list of entries."}
```scala
def loadProducts(): DatabasePublisher[(UUID, String, String)] = {
  val program = for {
    (p, ns) <- productsTable.join(namesTable).on(_.id === _.productId)
               .sortBy(_._1.id)
  } yield (p.id, ns.langCode, ns.name)
  dbConfig.db.stream(program.result)
}
```

Now we can rely on the fact that we have seen all entries for one product if the product id in our list changes. Let's adjust our code in the endpoint to make use of streaming now. Because Akka-HTTP is based on Akka-Streams we can simply use that.

{caption: "Return all products as stream"}
```scala
path("products") {
  get {
    implicit val jsonStreamingSupport: JsonEntityStreamingSupport =
      EntityStreamingSupport.json()

    val src = Source.fromPublisher(repo.loadProducts())
    val products: Source[Product, NotUsed] = src
      .collect(
        cs =>
          Product.fromDatabase(Seq(cs)) match {
            case Some(p) => p
        }
      )
      .groupBy(Int.MaxValue, _.id)
      .fold(Option.empty[Product])(
        (op, x) => op.fold(x.some)(p =>
          p.copy(names = p.names ::: x.names).some
        )
      )
      .mergeSubstreams
      .collect(
        op =>
          op match {
            case Some(p) => p
        }
      )
    complete(products)
  }
}
```

Wow, this may look scary but let's break it apart piece by piece. At first we need an implicit value which provides streaming support for JSON. Next we create a `Source` from the database stream. Now we implement the processing logic via the high level streams API. We collect every defined output of our helper function `fromDatabase` which leads to a stream of `Product` entities. But we have created way too many (Each product will be created as often as it has translations.). So we group our stream by the product id which creates a new stream for each product id holding only the entities for the specific product. We fold over each of these streams by merging together the list of translations (`names`). Afterwards we merge the streams back together and run another collect function to simply get a result stream of `Product` and not of `Option[Product]`. Last but not least the stream is passed to the `complete` function which will do the right thing.

### Problems with the solution

The solution has two problems:

1. The number of individual streams (and thus products) is limited to `Int.MaxValue`.
2. The `groupBy` operator holds the references to these streams in memory opening a possible out of memory issue here.

As the first problem is simply related to the usage of `groupBy` we may say that we only have one problem: The usage of `groupBy`. ;-)
For a limited amount of data the proposed solution is perfectly fine so we will leave it as is for now.

Regarding the state of our service we have a working solution, so congratulations and let's move on to the pure implementation.

# Pure implementation

Like in the previous section I will spare you the details of the sbt setup. We will be using the following set of libraries:

1. http4s
2. Doobie (as database layer)
3. Flyway for database migrations (or evolutions)
4. Circe for JSON codecs
5. Refined for using refined types
6. the PostgreSQL JDBC driver
7. pureconfig (for proper configuration loading)

## Pure configuration handling

Last time we simply loaded our configuration via the typesafe config library but can't we do a bit better here? The answer is yes by using the pureconfig[^12] library. First we start by implementing the necessary parts of our configuration as data types.

{caption: "Configuration data types"}
```scala
final case class ApiConfig(host: NonEmptyString, port: PortNumber)

object ApiConfig {
  implicit val configReader: ConfigReader[ApiConfig] =
    deriveReader[ApiConfig]
}

final case class DatabaseConfig(driver: NonEmptyString,
                                url: DatabaseUrl,
                                user: DatabaseLogin,
                                pass: DatabasePassword)

object DatabaseConfig {
  implicit val configReader: ConfigReader[DatabaseConfig] =
    deriveReader[DatabaseConfig]
}
```

As we can see the code is pretty simple. The implicits in the companion objects are needed for pureconfig to actually map from a configuration to your data types. As you can see we are using a function `deriveReader` which will derive (like in mathematics) the codec (Yes, it is similar to a JSON codec thus the name.) for us.

I> **A note on derivation**
I> In general we always want the compiler to derive stuff automatically because it means less work for us. However...
I> As always there is a cost and sometimes a rather big one (compile time). Therefore you should not use fully automatic derivation but the semi automatic variant instead. The latter will let you chose what to derive explicitly.
I> In some circumstances it may even be better to generate a codec manually (complex, deeply nested models).

Below is an example of deriving a `Order` instance using the kittens [^24]library. It uses shapeless under the hood and provides automatic and semi automatic derivation for a lot of type class instances from Cats like `Eq`, `Order`, `Show`, `Functor` and so on.

{caption: "Deriving Order via kittens"}
```scala
import cats._
import cats.derived

implicit val order: Order[Translation] = {
  import derived.auto.order._
  derived.semi.order[Translation]
}
```

## Models

Because we have already written our models we just re-use them here. The only thing we change is the semi automatic derivation of the JSON codecs. We just need to import the appropriate circe package and call the derive functions.

{caption: "Derive JSON codecs"}
```scala
import io.circe._
import io.circe.generic.semiauto._

implicit val decode: Decoder[Product] = deriveDecoder[Product]
implicit val encode: Encoder[Product] = deriveEncoder[Product]
implicit val decode: Decoder[Translation] = deriveDecoder[Translation]
implicit val encode: Encoder[Translation] = deriveEncoder[Translation]
```

I> Remind please that for complex classes this can add significant compile time overhead.
I> Also using (semi) automatic derivation for data models that are used in a public API may result in breaking changes if an attribute name is changed.

## Database layer

In general the same applies to the database layer as we have already read in the "impure" section.

### Migrations

For the sake of simplicity we will stick to Flyway for our database migrations. However we will wrap the migration code in a different way (read *Encapsulate it properly within an `IO` to defer side effects.*). While we're at it we may just as well write our migration code using the interpreter pattern (it became famous under the name "tagless final" in Scala).

{caption: "Database migrator base"}
```scala
trait DatabaseMigrator[F[_]] {
  def migrate(url: DatabaseUrl,
              user: DatabaseLogin,
              pass: DatabasePassword): F[Int]
}
```

We define a trait which describes the functionality desired by our interpreter and use a higher kinded type parameter to be able to abstract over the type. But now let's continue with our Flyway interpreter.

{caption: "Flyway migrator interpreter"}
```scala
final class FlywayDatabaseMigrator extends DatabaseMigrator[IO] {
  override def migrate(url: DatabaseUrl,
                       user: DatabaseLogin,
                       pass: DatabasePassword): IO[Int] =
    IO {
      val flyway: Flyway = Flyway.configure()
        .dataSource(url, user, pass)
        .load()
      flyway.migrate()
    }
}
```

As we can see, the implementation is pretty simple and we just wrap our code into an `IO` monad to constrain the effect. Having the migration code settled we can move on to the repository.

Q> So what is wrong with our solution?

If we take a closer look at the method definition of `Flyway.migrate`, we see this:

{caption: "Method definition of Flyway.migrate"}
```scala
public int migrate() throws FlywayException
```

While `IO` will gladly defer side effects for us it won't stop enclosed code from throwing exceptions. This is not that great. So what can we do about it?
Having an instance of `MonadError` in scope we could just use the `.attempt` function provided by it. But is this enough or better does this provide a sensible solution for us? Let's play a bit on the REPL.

{caption: "MonadError on the REPL"}
```scala
@ import cats._, cats.effect._, cats.implicits._
@ val program = for {
           _ <- IO(println("one"))
           _ <- IO(println("two"))
           x <- IO.pure(42)
           } yield x
@ program.attempt.unsafeRunSync match {
           case Left(e) =>
             println(e.getMessage)
             -1
           case Right(r) => r
           }
one
two
res3: Int = 42
@ val program = for {
           _ <- IO(println("one"))
           _ <- IO(throw new Error("BOOM!"))
           x <- IO.pure(42)
           } yield x
@ program.attempt.unsafeRunSync match {
           case Left(e) =>
             println(e.getMessage)
             -1
           case Right(r) => r
           }
one
BOOM!
res5: Int = -1
```

This looks like we just have to use `MonadError` then. Hurray, we don't need to change our code in the migrator. As model citizens of the functional programming camp we just defer the responsibility upwards to the calling site.

### Doobie

As we already started with using a tagless final approach we might as well continue with it and define a base for our repository.

{caption: "Base trait for the repository"}
```scala
trait Repository[F[_]] {
  def loadProduct(id: ProductId): F[Seq[(ProductId, LanguageCode, ProductName)]]

  def loadProducts(): Stream[F, (ProductId, LanguageCode, ProductName)]

  def saveProduct(p: Product): F[Int]

  def updateProduct(p: Product): F[Int]
}
```

There is nothing exciting here except that we feel brave now and try to use proper refined types in our database functions. This is possible due to the usage of the doobie-refined module. To be able to map the `UUID` data type (and others) we also need to include the doobie-postgresql module. For convenience we are still using `ProductId` instead of `UUID` in our definition. In addition we wire the return type of `loadProducts` to be a `fs2.Stream` because we want to achieve pure functional streaming here. :-)
So let's see what a repository using doobie looks like.

{caption: "The doobie repository."}
```scala
final class DoobieRepository[F[_]: Sync](tx: Transactor[F])
  extends Repository[F] {

  override def loadProduct(id: ProductId) = ???

  override def loadProducts() = ???

  override def saveProduct(p: Product) = ???

  override def updateProduct(p: Product) = ???
}
```

We keep our higher kinded type as abstract as we can but we want it to be able to suspend our side effects. Therefore we require an implicit `Sync`.[^13]
If we look at the detailed function definitions further below, the first big difference is that with doobie you write plain SQL queries. You can do this with Slick too[^14] but with doobie it is the only way. If you're used to object relational mapping (ORM) or other forms of query compilers then this may seem strange at first. But: "In data processing it seems, all roads eventually lead back to SQL!"[^15] ;-)
We won't discuss the benefits or drawbacks here but in general I also lean towards the approach of using the de facto lingua franca for database access because it was made for this and so far no query compiler was able to beat hand crafted SQL in terms of performance. Another benefit is that if you ask a database guru for help, she will be much more able to help you with plain SQL queries than with some meta query which is compiled into something that you have no idea of.

{caption: "Loading a product."}
```scala
override def loadProduct(id: ProductId) = 
  sql"""SELECT products.id, names.lang_code, names.name 
        FROM products
        JOIN names ON products.id = names.product_id
        WHERE products.id = $id"""
    .query[(ProductId, LanguageCode, ProductName)]
    .to[Seq]
    .transact(tx)
```

The `loadProduct` function simply returns all rows for a single product from the database like its Slick counterpart in the impure variant. The parameter will be correctly interpolated by Doobie therefore we don't need to worry about SQL injections here. We specify the type of the query, instruct Doobie to transform it into a sequence and give it to the transactor.

I> Please note that instead of the Slick variant the code does not run at that point!
I> While the `db.run` of Slick will run your code the `transact` of Doobie will not. It just provides a free structure (read *free monads*) which can be interpreted later on.

{caption: "Load all products"}
```scala
override def loadProducts() =
  sql"""SELECT products.id, names.lang_code, names.name
      FROM products
      JOIN names ON products.id = names.product_id
      ORDER BY products.id"""
    .query[(ProductId, LanguageCode, ProductName)]
    .stream
    .transact(tx)
```

Our `loadProducts` function is equivalent to the first one but it returns the data for all products sorted by product and as a stream using the fs2 library which provides pure functional streaming.

{caption: "Save a product"}
```scala
override def saveProduct(p: Product): F[Int] = {
  val namesSql = 
    "INSERT INTO names (product_id, lang_code, name) VALUES (?, ?, ?)"
  val namesValues = p.names.map(t => (p.id, t.lang, t.name))
  val program = for {
    pi <- sql"INSERT INTO products (id) VALUES(${p.id})".update.run
    ni <- Update[(ProductId, LanguageCode, ProductName)](namesSql)
            .updateMany(namesValues)
  } yield pi + ni
  program.transact(tx)
}
```

When saving a product we use monadic notation for our program to have it short circuit in the case of failure. Doobie will also put all commands into a database transaction. The function itself will try to create the "master" entry into the products table and save all translations afterwards.

{caption: "Update a product"}
```scala
override def updateProduct(p: Product): F[Int] = {
  val namesSql =
    "INSERT INTO names (product_id, lang_code, name) VALUES (?, ?, ?)"
  val namesValues = p.names.map(t => (p.id, t.lang, t.name))
  val program = for {
    dl <- sql"DELETE FROM names WHERE product_id = ${p.id}".update.run
    ts <- Update[(ProductId, LanguageCode, ProductName)](namesSql)
            .updateMany(namesValues)
  } yield dl + ts
  program.transact(tx)
}
```

The `updateProduct` function uses also monadic notation like the `saveProduct` function we talked about before. The difference is that it first deletes all known translations before saving the given ones.

## http4s routes

The routing DSL of http4s differs from the one of Akka-HTTP. Although I like the latter one more it poses no problem to model out a base for our routes.

{caption: "Base for http4s routes"}
```scala
val productRoutes: HttpRoutes[IO] = HttpRoutes.of[IO] {
  case GET -> Root / "product" / id =>
    ???
  case PUT -> Root / "product" / id =>
    ???
}
val productsRoutes: HttpRoutes[IO] = HttpRoutes.of[IO] {
  case GET -> Root / "products" =>
    ???
  case POST -> Root / "products" =>
    ???
}
```

As we can see the DSL is closer to Scala syntax and quite easy to read. But before we move on to the details of each route let's think about how we can model this a bit more abstract. While it is fine to have our routes bound to `IO` it would be better to have more flexibility here. We have several options here but for starters we just extract our routes into their own classes like in the following schema.

{caption: "Routing classes"}
```scala
final class ProductRoutes[F[_]: Sync](repo: Repository[F])
  extends Http4sDsl[F] {

  val routes: HttpRoutes[F] = HttpRoutes.of[F] {
    case GET -> Root / "product" / UUIDVar(id) =>
      ???
    case req @ PUT -> Root / "product" / UUIDVar(id) =>
      ???
  }
}

final class ProductsRoutes[F[_]: Sync](repo: Repository[F]) 
  extends Http4sDsl[F] {

  val routes: HttpRoutes[F] = HttpRoutes.of[F] {
    case GET -> Root / "products" =>
      ???
    case req @ POST -> Root / "products" =>
      ???
  }
}
```

So far they only need the repository to access and manipulate data. Now let's take on the single route implementations.

{caption: "Product routes"}
```scala
final class ProductRoutes[F[_]: Sync](repo: Repository[F])
  extends Http4sDsl[F] {
  implicit def decodeProduct = jsonOf
  implicit def encodeProduct = jsonEncoderOf

  val routes: HttpRoutes[F] = HttpRoutes.of[F] {
    case GET -> Root / "product" / UUIDVar(id) =>
      for {
        rows <- repo.loadProduct(id)
        resp <- Ok(Product.fromDatabase(rows))
      } yield resp
    case req @ PUT -> Root / "product" / UUIDVar(id) =>
      for {
        p <- req.as[Product]
        _ <- repo.updateProduct(p)
        r <- NoContent()
      } yield r
  }
}
```

First we need to bring JSON codecs in scope for http4s thus the implicit definitions on top of the file. In the route for loading a single product we simply load the database rows which we pipe through our helper function to construct a proper `Product` and return that.
The update route (via `PUT`) transforms the request body into a `Product` and gives that to the update function of the repository. Finally a `NoContent` response is returned.

{caption: "Products routes (1st try)"}
```scala
final class ProductsRoutes[F[_]: Sync](repo: Repository[F])
  extends Http4sDsl[F] {
  implicit def decodeProduct = jsonOf
  implicit def encodeProduct = jsonEncoderOf

  val routes: HttpRoutes[F] = HttpRoutes.of[F] {
    case GET -> Root / "products" =>
      val ps: Stream[F, Product] = repo.loadProducts
        .map(cs => Product.fromDatabase(List(cs)))
        .collect {
          case Some(p) => p
        }
      Ok(ps)
    case req @ POST -> Root / "products" =>
      for {
        p <- req.as[Product]
        _ <- repo.saveProduct(p)
        r <- NoContent()
      } yield r
  }
}
```

Our first take on the routes for products looks pretty complete already. Again we need implicit definitions for our JSON codecs to be able to serialize and de-serialize our entities. The `POST` route for creating a product is basically the same as the update route from the previous part. We create a `Product` from the request body, pass it to the save function of the repository and return a 205 `NoContent` response.
The `GET` route for returning all products calls the appropriate repository function which returns a stream which we map over using our helper function. Afterwards we use `collect` to convert our stream from `Option[Product]` to a stream of `Product` which we pass to the `Ok` function of http4s.

I> The attentive reader will have noticed that our "fetch all products" implementation faces the same problem as our first try in the impure section: We return to many products!

To solve this we need to dive into the fs2 API and leverage it's power to merge our products back together. So let's see how we do.

### Streaming - Take 1

Because we believe ourselves to be clever we pick the simple sledge hammer approach and just run some accumulator on the stream. So what do we need? A helper function and some code changes on the stream (e.g. in the route).

{caption: "Merging products"}
```scala
def merge(ps: List[Product])(p: Product): List[Product] =
  ps.headOption.fold(List(p)) { h =>
    if (h.id === p.id)
      h.copy(names = h.names ::: p.names) :: ps.drop(1)
    else
      p :: ps
  }
```

So this function will take a list (that may be empty) and a product and will merge the top most element (the head) of the list with the given one. It will return an updated list that either contains an updated head element or a new head. Leaving aside the question of who guarantees that the relevant list element will always be the head, we may use it.

{caption: "Adapted streaming route"}
```scala
case GET -> Root / "products" =>
  val ps: Stream[F, Product] = repo.loadProducts
    .map(cs => Product.fromDatabase(List(cs)))
    .collect {
      case Some(p) => p
    }
    .fold(List.empty[Product])((acc, p) => Product.merge(acc)(p))
  Ok(ps)
```

Looks so simple, does it? Just a simple `fold` which uses our accumulator and we should be settled. But life is not that simple...

{caption: "Compiler error"}
```text
found   : fs2.Stream[F,List[com.wegtam.books.pfhais.pure.models.Product]]
required: fs2.Stream[F,com.wegtam.books.pfhais.pure.models.Product]
         .fold(List.empty[Product])((acc, p) => Product.merge(acc)(p))
              ^
```

The compiler complains that we have changed the type of the stream and rightly so. So let's fix that compiler error.

Q> Should we really do this?

Let's take a look again and think about what it means to change a stream of products into a stream of a list of products. It means that we will be building the whole thing in memory! Well if we wanted that we could have skipped streaming at all. So back to the drawing board.

### Streaming - Take 2

We need to process our stream of database columns (or products if we use the converter like before) in such a way that all related entities will be grouped into one product and emitted as such. After browsing the documentation of fs2 we stumble upon a function called `groupAdjacentBy` so we try that one.

{caption: "Proper streaming of products"}
```scala
case GET -> Root / "products" =>
  val ps = repo.loadProducts
    .groupAdjacentBy(_._1)
    .map {
      case (id, rows) => Product.fromDatabase(rows.toList)
    }
    .collect {
      case Some(p) => p
    }
  Ok(ps)
```

Okay, this does not look complicated and it even compiles - Hooray! :-)
So let's break it apart piece by piece. The group function of fs2 will partition the input depending on the given function into chunks. A `Chunk` is used internally by fs2 for all kinds of stuff. You may compare it to a sub-stream of Akka-Streams. However the documentation labels it as: *Strict, finite sequence of values that allows index-based random access of elements.*
Having our chunks we can map over each one converting it into a list which is then passed to our helper function `fromDatabase` to create proper products. Last but not least we need to collect our entities to get from an `Option[Product]` to a stream of `Product`.

### JSON trouble

Now that we have a proper streaming solution we try it out but what do we get when we expect a list of products?

I> In case you wonder what the `http` command is, we use the tool httpie[^16] for querying our service.

{caption: "Broken JSON"}
```text
% http :53248/products
HTTP/1.1 200 OK
Content-Type: application/json
Transfer-Encoding: chunked

{
  "id":"8773899b-fcfa-401f-af3e-b188ebb0c00c",
  "names":[
    {"lang":"de","name":"Erdbeere"},
    {"lang":"en","name":"Strawberry"}
  ]
}
{
  "id":"983aaf86-abe4-44af-9896-d8f2d2c5f82c",
  "names":[
    {"lang":"de","name":"Gurke"},
    {"lang":"en","name":"Cucumber"}
  ]
}
```

Well, whatever this is, it is not JSON! It might look like it, but it isn't. However quite often you can see such things in the wild (read *in production*).

Q> So, how can we improve this?

If we think about it then this sounds like a bug in http4s and indeed we find an issue[^17] for it. Because the underlying problem is not as trivial as it first sounds maybe we should try to work around the issue.
The fs2 API offers concatenation of streams and the nifty `intersperse` function to insert elements between emitted ones. So let's give it a try.

{caption: "Fix JSON encoding issues"}
```scala
case GET -> Root / "products" =>
  val prefix = Stream.eval("[".pure[F])
  val suffix = Stream.eval("]".pure[F])
  val ps = repo.loadProducts
    .groupAdjacentBy(_._1)
    .map {
      case (id, rows) => Product.fromDatabase(rows.toList)
    }
    .collect {
      case Some(p) => p
    }
    .map(_.asJson.noSpaces)
    .intersperse(",")
  @SuppressWarnings(Array("org.wartremover.warts.Any"))
  val result: Stream[F, String] = prefix ++ ps ++ suffix
  Ok(result)
```

First we create streams for the first and last JSON that we need to emit. Please note that we cannot simply use a `String` here but have to lift it into our HKT `F`. The usage of `pure` is okay because we simply lift a fixed value. Then we extend our original stream processing by explicitly converting our products to JSON and inserting the delimiter (a comma) manually using the `intersperse` function. In the end we simply concatenate our streams and return the result.
Our solution is quite simple, having the downside that we need to suppress a warning from the wartremover[^18] tool. This is somewhat annoying but can happen. If we remove the annotation, we'll get a compiler error:

{caption: "Wartremover error"}
```text
[error] ... [wartremover:Any] Inferred type containing Any
[error] val result: Stream[F, String] = prefix ++ ps ++ suffix
[error]                                        ^
[error] ... [wartremover:Any] Inferred type containing Any
[error] val result: Stream[F, String] = prefix ++ ps ++ suffix
[error]                                              ^
[error] two errors found
```

So let's check if we have succeeded:

{caption: "Checking our JSON"}
```text
% http :53248/products
HTTP/1.1 200 OK
Content-Type: text/plain; charset=UTF-8
Transfer-Encoding: chunked

[
    {
        "id": "8773899b-fcfa-401f-af3e-b188ebb0c00c", 
        "names": [
            {
                "lang": "de",
                "name": "Erdbeere"
            },
            {
                "lang": "en",
                "name": "Strawberry"
            }
        ]
    },
    {
        "id": "983aaf86-abe4-44af-9896-d8f2d2c5f82c", 
        "names": [
            {
                "lang": "de",
                "name": "Gurke"
            },
            {
                "lang": "en",
                "name": "Cucumber"
            }
        ]
    }
]
```

This looks good, so we congratulations: We are done with our routes!

### Starting the application

Within our main entry point we simply initialise all needed components and wire them together. We'll step through each part in this section. The first thing you'll notice is that we use the `IOApp` provided by the Cats effect library[^19].

{caption: "Main application"}
```scala
object Pure extends IOApp {
  @SuppressWarnings(Array("org.wartremover.warts.Any"))
  def run(args: List[String]): IO[ExitCode] = ???
}
```

Yet again we need to suppress a warning from wartremover here. But let's continue to initialising the database connection.

{caption: "Database initialisation"}
```scala
val migrator: DatabaseMigrator[IO] = new FlywayDatabaseMigrator

val program = for {
  (apiConfig, dbConfig) <- IO {
    val cfg = ConfigFactory.load
    (loadConfigOrThrow[ApiConfig](cfg, "api"),
     loadConfigOrThrow[DatabaseConfig](cfg, "database"))
  }
  ms <- migrator.migrate(dbConfig.url, dbConfig.user, dbConfig.pass)
  tx = Transactor
    .fromDriverManager[IO](dbConfig.driver,
      dbConfig.url,
      dbConfig.user,
      dbConfig.pass)
  repo = new DoobieRepository(tx)
```

We create our database migrator explicitly wired to the `IO` data type. Now we start with a for comprehension in which we load our configuration via pureconfig yet again within an `IO`. After successful loading of the configuration we continue with migrating the database. Finally we create the transactor needed by Doobie and the database repository.

{caption: "Routes and http4s server"}
```scala
val program = for {
  // ...
  productRoutes  = new ProductRoutes(repo)
  productsRoutes = new ProductsRoutes(repo)
  routes         = productRoutes.routes <+> productsRoutes.routes
  httpApp        = Router("/" -> routes).orNotFound
  server         = BlazeServerBuilder[IO].bindHttp(apiConfig.port,
                     apiConfig.host).withHttpApp(httpApp)
  fiber          = server.resource.use(_ => IO(StdIn.readLine())).as(ExitCode.Success)
} yield fiber
```

Here we create our routes via the classes, combine them (via `<+>` operator) and create the http4s app explicitly using an `IO` thus wiring our abstract routes to `IO`. The service will - like the impure one - run until you press enter. But it won't run yet. ;-)

{caption: "Running the service"}
```scala
program.attempt.unsafeRunSync match {
  case Left(e) =>
    IO {
      println("*** An error occured! ***")
      if (e != null) {
        println(e.getMessage)
      }
      ExitCode.Error
    }
  case Right(r) => r
}
```

If you remember playing around with `MonadError` then you'll recognize the `attempt` here. We attempt to run our program and execute possible side effects via the `unsafeRunSync` method from Cats effect. But to provide a proper return type for the `IOApp` we need to evaluate the return value which is either an error or a proper exit code. In case of an error we print it out on the console (no fancy logging here) and explicitly set an error code as the return value.

I> Please note that we also wrap our error handler into an `IO` to defer possible side effects.

As it seems we are done with our pure service! Or are we? Let's see what we need add to both services if we want to test them.

# What about tests?

In the domain of strong static typing (not necessarily functional) you might hear phrases like "It compiles therefore it must be correct thus we don't need tests!". While there is a point that certain kinds of tests can be omitted in favour of strong static typing such stances overlook that even a correctly typed program may produce the wrong output. The other extreme (coming from dynamic typed land) is to substitute typing with testing - which is even worse. Remember that testing is usually a probabilistic approach and cannot guarantee the absence of bugs. If you have ever refactored a large code base in both paradigms then you'll very likely come to esteem a good type system.

However, we need tests, so let's write some. But before let us think a bit about what kinds of tests we need. :-)
Our service must read and create data in the JSON format. This format should be fixed and changes to it should raise some red flag because: Hey, we just broke our API! Furthermore we want to unleash the power of ScalaCheck[^20] to benefit from property based testing. But even when we're not using that we can still use it to generate test data for us.
Besides the regular unit tests there should be integration tests if a service is written. We can test a lot of things on the unit test side but in the end the integration of all our moving parts is what matters and often (usually on the not so pure side of things) you would have to trick (read *mock*) a lot to test things in isolation.

## Testing the impure service

We will start with writing some data generators using the ScalaCheck library.

### Generators

ScalaCheck already provides several generators for primitives but for our data models we have to do some more plumbing. Let's start with generating a language code.

{caption: "ScalaCheck generate LanguageCode"}
```scala
val genLanguageCode: Gen[LanguageCode] = Gen.oneOf(LanguageCodes.all)
```

Using the `Gen.oneOf` helper from the library the code becomes dead simple. Generating a `UUID` is nothing special either.

{caption: "ScalaCheck generate UUID"}
```scala
val genUuid: Gen[UUID] = Gen.delay(UUID.randomUUID)
)
```

You might be tempted to use `Gen.const` here but please don't because that one will be memorized and thus never change. Another option is using a list of randomly generated UUID values from which we then chose one. That would be sufficient for generators which only generate a single product but if we want to generate lists of them we would have duplicate ids sooner than later.

{caption: "ScalaCheck generate ProductName"}
```scala
val DefaultProductName: ProductName = "I am a product name!"
val genProductName: Gen[ProductName] = for {
  cs <- Gen.nonEmptyListOf(Gen.alphaNumChar)
  name = RefType.applyRef[ProductName](cs.mkString)
           .getOrElse(DefaultProductName)
} yield name
```

So what do we have here? We want to generate a non empty string (because that is a requirement for our `ProductName`) but we also want to return a properly typed entity. First we let ScalaCheck generate a non empty list of random characters which we give to a utility function of refined. However we need a fallback value in case the validation done by refined fails. Therefore we defined a general default product name beforehand.

I> If the data generated will always be valid then we can simplify the code above by using the `Refined.unsafeApply` function. This reduces code complexity but may introduce bugs in your tests which are hard to track down.

{caption: "ScalaCheck using Refined unsafeApply"}
```scala
val genProductName: Gen[ProductName] =
  Gen.nonEmptyListOf(Gen.alphaNumChar).map(cs => 
    Refined.unsafeApply(cs.mkString)
  )
```

Now that we have generators for language codes and product names we can write a generator for our `Translation` type.

{caption: "ScalaCheck generate Translation"}
```scala
val genTranslation: Gen[Translation] = for {
  c <- genLanguageCode
  n <- genProductName
} yield
  Translation(
    lang = c,
    name = n
  )

implicit val arbitraryTranslation: Arbitrary[Translation] =
  Arbitrary(genTranslation)
```

As we can see the code is also quite simple. Additionally we create an implicit arbitrary value which will be used automatically by the `forAll` test helper if it is in scope. To be able to generate a `Product` we will need to provide a non empty list of translations.

{caption: "ScalaCheck generate lists of translations"}
```scala
val genTranslationList: Gen[List[Translation]] = for {
  ts <- Gen.nonEmptyListOf(genTranslation)
} yield ts

val genNonEmptyTranslationList: Gen[NonEmptyList[Translation]] = for {
  t  <- genTranslation
  ts <- genTranslationList
  ns = NonEmptyList.fromList(ts)
} yield ns.getOrElse(NonEmptyList.of(t))
```

The first generator will create a non empty list of translations but will be typed as a simple `List`. Therefore we create a second generator which uses the `fromList` helper of the non empty list from Cats. Because that helper returns an `Option` (read *is a safe function*) we need to fallback to using a simple `of` function at the end.
With all these in place we can finally create our `Product` instances.

{caption: "ScalaCheck generate Product"}
```scala
val genProduct: Gen[Product] = for {
  id <- genProductId
  ts <- genNonEmptyTranslationList
} yield
  Product(
    id = id,
    names = ts
  )

implicit val arbitraryProduct: Arbitrary[Product] =
  Arbitrary(genProduct)
```

The code is basically the same as for `Translation` - the arbitrary implicit included.

### Unit Tests

To avoid repeating the construction of our unit test classes we will implement a base class for tests which is quite simple.

{caption: "Base class for unit tests"}
```scala
abstract class BaseSpec extends WordSpec 
  with MustMatchers with ScalaCheckPropertyChecks {}
```

Feel free to use other test styles - after all ScalaTest offers a lot[^21] of them. I tend to lean towards the more verbose ones like `WordSpec`. Maybe that is because I spent a lot of time with RSpec[^22] in the Ruby world. ;-)

{caption: "Testing Product#fromDatabase"}
```scala
import com.wegtam.books.pfhais.impure.models.TypeGenerators._

forAll("input") { p: Product =>
  val rows = p.names.map(t => (p.id, t.lang.value, t.name.value)).toList
  Product.fromDatabase(rows) must contain(p)
}
```

The code above is a very simple test of our helper function `fromDatabase` which works in the following way:

1. The `forAll` will generate a lot of `Product` entities using the generator.
2. From each entity a list of "rows" is constructed like they would appear in the database.
3. These constructed rows are given to the `fromDatabase` function.
4. The returned `Option` must then contain the generated value.

Because we construct the input for the function from a valid generated instance the function must always return a valid output.

Now let's continue with testing our JSON codec for `Product`.

#### Testing a JSON codec

We need our JSON codec to provide several guarantees:

1. It must fail to decode invalid JSON input format (read *garbage*).
2. It must fail to decode valid JSON input format with invalid data (read *wrong semantics*).
3. It must succeed to decode completely valid input.
4. It must encode JSON which contains all fields included in the model.
5. It must be able to decode JSON that itself encoded.

The first one is pretty simple and to be honest: You don't have to write a test for this because that should be guaranteed by the Circe library. Things look a bit different for very simple JSON representations though (read *when encoding to numbers or strings*).
I've seen people arguing about point 5 and there may be applications for it but implementing encoders and decoders in a non-reversible way will make your life way more complicated.

{caption: "Testing decoding garbage input"}
```scala
forAll("input") { s: String =>
  decode[Product](s).isLeft must be(true)
}
```

There is not much to say about the test above: It will generate a lot of random strings which will be passed to the decoder which must fail.

{caption: "Testing invalid input values"}
```scala
forAll("id", "names") { (id: String, ns: List[String]) =>
  val json = """{
    |"id":""" + id.asJson.noSpaces + """,
    |"names":""" + ns.asJson.noSpaces + """
    |}""".stripMargin
  decode[Product](json).isLeft must be(true)
}
```

This test will generate random instances for `id` which are all wrong because it must be a UUID and not a string. Also the instances for `names` will mostly (but maybe not always) be wrong because there might be empty strings or an even empty list. So the decoder is given a valid JSON format but invalid values, therefore it must fail.

{caption: "Testing valid input"}
```scala
forAll("input") { i: Product =>
  val json = s"""{
    |"id": ${i.id.asJson.noSpaces},
    |"names": ${i.names.asJson.noSpaces}
    |}""".stripMargin
  withClue(s"Unable to decode JSON: $json") {
    decode[Product](json) match {
      case Left(e)  => fail(e.getMessage)
      case Right(v) => v must be(i)
    }
  }
}
```

In this case we manually construct a valid JSON input using values from a generated valid `Product` entity. This is passed to the decoder and the decoder must not only succeed but return an instance equal to the generated one.

{caption: "Test included fields"}
```scala
forAll("input") { i: Product =>
  val json = i.asJson.noSpaces
  json must include(s""""id":${i.id.asJson.noSpaces}""")
  json must include(s""""names":${i.names.asJson.noSpaces}""")
}
```

The test will generate again a lot of entities and we construct a JSON string from each. We then expect the string to include several field names and their correctly encoded values. You might ask why we do not check for more things like: Are these fields the *only* ones within the JSON string? Well, this would be more cumbersome to test and a JSON containing more fields than we specify won't matter for the decoder because it will just ignore them.

I> You might be tempted to produce a JSON string manually (like in the other tests) and simply compare the generated one to it. Please beware because JSON does not provide stable sorted attributes (fields). So you might get false positives because the compared strings are semantically equal but formally different.

{caption: "Decoding encoded JSON"}
```scala
forAll("input") { p: Product =>
  decode[Product](p.asJson.noSpaces) match {
    case Left(_)  => fail("Must be able to decode encoded JSON!")
    case Right(d) => withClue("Must decode the same product!")(d must be(p))
  }
}
```

Here we encode a generated entity and pass it to the encoder which must return the same entity.

#### More tests

So this is basically what we do for models. Because we have more than one we will have to write tests for each of the others. I will spare you the JSON tests for `Translation` but that one also has a helper function called `fromUnsafe` so let's take a look at the function.

{caption: "Translation#fromUnsafe"}
```scala
def fromUnsafe(lang: String)(name: String): Option[Translation] =
  for {
    l <- RefType.applyRef[LanguageCode](lang).toOption
    n <- RefType.applyRef[ProductName](name).toOption
  } yield Translation(lang = l, name = n)
```

This function simply tries to create a valid `Translation` entity from unsafe input values using the helpers provided by refined. As we can see it is a total function (read *is safe to use*). To cover all corner cases we must test it with safe and unsafe input.

{caption: "Testing Translation#fromUnsafe (1)"}
```scala
forAll("lang", "name") { (l: String, n: String) =>
  whenever(
    RefType
      .applyRef[LanguageCode](l)
      .toOption
      .isEmpty || RefType.applyRef[ProductName](n).toOption.isEmpty
  ) {
    Translation.fromUnsafe(l)(n) must be(empty)
  }
}
```

Here we generate two random strings which we explicitly check to be invalid using the `whenever` helper. Finally the function must return an empty `Option` e.g. `None` for such values.

{caption: "Testing Translation#fromUnsafe (2)"}
```scala
forAll("input") { t: Translation =>
  Translation.fromUnsafe(t.lang.value)(t.name.value) must contain(t)
}
```

The test for valid input is very simple because we simply use the values from our automatically generated valid instances. :-)

Q> So what is left to test?

So far we have no tests for our `Repository` class which handles all the database work. Neither have we tests for our routes. We have several options for testing here but before can test either of them we have do to some refactoring. For starters we should move our routes out of our main application into separate classes to be able to test them more easily.

Q> But should we refactor code only to gain better testability?

Yes, we should. There are of course limits and pros and cons to that but in general this makes sense. Also this has nothing to do with being "impure" or "pure" but with clean structure.

#### Some refactoring

Moving the routes into separate classes poses no big problem we simply create a `ProductRoutes` and a `ProductsRoutes` class which will hold the appropriate routes. As a result our somewhat messy main application code becomes more readable.

{caption: "New Impure main application"}
```scala
def main(args: Array[String]): Unit = {
  implicit val system: ActorSystem    = ActorSystem()
  implicit val mat: ActorMaterializer = ActorMaterializer()
  implicit val ec: ExecutionContext   = system.dispatcher

  val url = ???
  val user           = ???
  val pass           = ???
  val flyway: Flyway = ???
  val _              = flyway.migrate()

  val dbConfig: DatabaseConfig[JdbcProfile] =
    DatabaseConfig.forConfig("database", system.settings.config)
  val repo = new Repository(dbConfig)

  val productRoutes  = new ProductRoutes(repo)
  val productsRoutes = new ProductsRoutes(repo)
  val routes         = productRoutes.routes ~ productsRoutes.routes

  val host       = system.settings.config.getString("api.host")
  val port       = system.settings.config.getInt("api.port")
  val srv        = Http().bindAndHandle(routes, host, port)
  val pressEnter = StdIn.readLine()
  srv.flatMap(_.unbind()).onComplete(_ => system.terminate())
}
```

We simply create our instances from our routing classes and construct our global routes directly from them. This is good but if we want to test the routes in isolation we still have the problem that they are hard-wired to our `Repository` class which is implemented via Slick. Several options exist to handle this:

1. Use an in-memory test database with according configuration.
2. Abstract further and use a trait instead of the concrete repository implementation.
3. Write integration tests which will require a working database.

Using option 1 is tempting but think about it some more. While the benefit is that we can use our actual implementation and just have to fire up an in-memory database (for example h2), there are also some drawbacks:

1. You have to handle evolutions for the in-memory database.
2. Your evolutions have to be completely portable SQL (read *ANSI SQL*). Otherwise you'll have to write each of your evolutions scripts two times (one for production, one for testing).
3. Your code has to be database agnostic. This sounds easier than it is. Even the tools you're using may use database specific features under the hood.
4. Several features are simply not implemented in some databases. Think of things like cascading deletion via foreign keys.

Taking option 2 is a valid choice but it will result in more code. Also you must pay close attention to the "test repository" implementation to avoid introducing bugs there. Going for the most simple approach is usually feasible. Think of a simple test repository implementation that will just return hard coded values or values passed to it via constructor.

However we will go with option 3 in this case. It has the drawback that you'll have to provide a real database environment (and maybe more) for testing. But it is as close to production as you can get. Also you will need these either way to test your actual repository implementation, so let's get going.

### Integration Tests

First we need to configure our test database because we do not want to accidentally wipe a production database. For our case we leave everything as is and just change the database name.

{caption: "Configuration file for integration tests"}
```text
api {
  host = "localhost"
  port = 49152
}

database {
  profile = "slick.jdbc.PostgresProfile$"
  db {
    connectionPool = "HikariCP"
    dataSourceClass = "org.postgresql.ds.PGSimpleDataSource"
    properties {
      serverName = "localhost"
      portNumber = "5432"
      databaseName = "impure_test"
      user = "impure"
      password = "secret"
    }
    numThreads = 10
  }
}
```

Another thing we should do is provide a test configuration for our logging framework. We use the logback library and Slick will produce a lot of logging output on the `DEBUG` level so we should fix that. It is nice to have logging if you need it but it also clutters up your log files. We create a file `logback-test.xml` in the directory `src/it/resources` which should look like this:

{caption: "Logging configuration for integration tests"}
```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration debug="false">
  <appender name="console" class="ch.qos.logback.core.ConsoleAppender">
    <filter class="ch.qos.logback.classic.filter.ThresholdFilter">
      <level>WARN</level>
    </filter>
    <encoder>
      <pattern>%date %highlight(%-5level) %cyan(%logger{0}) - %msg%n</pattern>
    </encoder>
  </appender>

  <appender name="async-console" class="ch.qos.logback.classic.AsyncAppender">
    <appender-ref ref="console"/>
    <queueSize>5000</queueSize>
    <discardingThreshold>0</discardingThreshold>
  </appender>

  <logger name="com.wegtam.books.pfhais.impure" level="INFO" additivity="false">
    <appender-ref ref="console"/>
  </logger>

  <root>
    <appender-ref ref="console"/>
  </root>
</configuration>
```

Due to the nature of integration tests we want to use production or "production like" settings and environment. But really starting our application or service for each test will be quite cumbersome so we should provide a base class for our tests. In this class we will start our service, migrate our database and provide an opportunity to shut it down properly after testing.

Because we do not want to get into trouble when running an Akka-HTTP on the same port, we first create a helper function which will determine a free port number.

{caption: "Finding a free port number for tests"}
```scala
import java.net.ServerSocket

def findAvailablePort(): Int = {
  val serverSocket = new ServerSocket(0)
  val freePort     = serverSocket.getLocalPort
  serverSocket.setReuseAddress(true)
  serverSocket.close()
  freePort
}
```

The code is quite simple and very useful for such cases. Please note that it is important to use `setReuseAddress` because otherwise the found socket will be blocked for a certain amount of time. But now let us continue with our base test class.

{caption: "BaseSpec for integration tests"}
```scala
abstract class BaseSpec
    extends TestKit(
      ActorSystem(
        "it-test",
        ConfigFactory
          .parseString(s"api.port=${BaseSpec.findAvailablePort()}")
          .withFallback(ConfigFactory.load())
      )
    )
    with AsyncWordSpecLike
    with MustMatchers
    with ScalaCheckPropertyChecks
    with BeforeAndAfterAll
    with BeforeAndAfterEach {

  implicit val materializer: ActorMaterializer = ActorMaterializer()

  private val url  = ???
  private val user = ???
  private val pass = ???
  protected val flyway: Flyway = 
    Flyway.configure().dataSource(url, user, pass).load()

  override protected def afterAll(): Unit =
    TestKit.shutdownActorSystem(system, FiniteDuration(5, SECONDS))

  override protected def beforeAll(): Unit = {
    val _ = flyway.migrate()
  }
}
```

As you can see we are using the Akka-Testkit to initialise an actor system. This is useful because there are several helpers available which you might need. We configure the actor system with our free port using the loaded configuration as fallback. Next we globally create an actor materializer which is needed by Akka-HTTP and Akka-Streams. Also we create a globally available Flyway instance to make cleaning and migrating the database easier.
The base class also implements the `beforeAll` and `afterAll` methods which will be run before and after all tests. They are used to initially migrate the database and to shut down the actor system properly in the end.

#### Testing the repository

Now that we our parts in place we can write an integration test for our repository implementation.

I> Please ensure that you have a properly configured database running!

First we need to do some things globally for the test scope.

{caption: "Repository test: global stuff"}
```scala
private val dbConfig: DatabaseConfig[JdbcProfile] =
  DatabaseConfig.forConfig("database", system.settings.config)
private val repo = new Repository(dbConfig)

override protected def beforeEach(): Unit = {
  flyway.clean()
  val _ = flyway.migrate()
  super.beforeEach()
}

override protected def afterEach(): Unit = {
  flyway.clean()
  super.afterEach()
}

override protected def afterAll(): Unit = {
  repo.close()
  super.afterAll()
}
```

We create one `Repository` instance for all our tests here. The downside is that if one test crashes it then the other will be affected too. On the other hand we avoid running into database connection limits and severe code limbo to ensure closing a repository connection after each test no matter the result.
Also we clean and migrate before each test and clean also after each test. This ensures having a clean environment.

D> However, not cleaning your database between tests might be an even more thorough test. ;-)

Onwards to the test for loading a single product.

{caption: "Repository test: loadProduct"}
```scala
"#loadProduct" when {
  "the ID does not exist" must {
    "return an empty list of rows" in {
      val id = UUID.randomUUID
      for {
        rows <- repo.loadProduct(id)
      } yield {
        rows must be(empty)
      }
    }
  }

  "the ID exists" must {
    "return a list with all product rows" in {
      genProduct.sample match {
        case None => fail("Could not generate data sample!")
        case Some(p) =>
          for {
            _    <- repo.saveProduct(p)
            rows <- repo.loadProduct(p.id)
          } yield {
            Product.fromDatabase(rows) match {
              case None => fail("No product created from database rows!")
              case Some(c) =>
                c.id must be(p.id)
                c mustEqual p
            }
          }
      }
    }
  }
}
```

Loading a non existing product must not produce any result and is simple to test if our database is empty. Testing the loading of a real product is not that much more complicated. We use the ScalaCheck generators to create one, save it and load it again. The loaded product must of course be equal to the saved one.

I> You might have noticed that we do not use `forAll` here and thus are testing only one case.
I> This is due an issue which has yet to be fixed[^23] in ScalaTest.

{caption: "Repository test: loadProducts"}
```scala
"#loadProducts" when {
  "no products exist" must {
    "return an empty stream" in {
      val src = Source.fromPublisher(repo.loadProducts())
      for {
        ps <- src.runWith(Sink.seq)
      } yield {
        ps must be(empty)
      }
    }
  }

  "some products exist" must {
    "return a stream with all product rows" in {
      genProducts.sample match {
        case None => fail("Could not generate data sample!")
        case Some(ps) =>
          val expected = ps.flatMap(
          p => p.names.toNonEmptyList.toList.map(
            n => (p.id, n.lang, n.name)
            )
          )
          for {
            _ <- Future.sequence(ps.map(p => repo.saveProduct(p)))
            src = Source
              .fromPublisher(repo.loadProducts())
              // more code omitted here
            rows <- src.runWith(Sink.seq)
          } yield {
            rows must not be (empty)
            rows.size mustEqual ps.size
            rows.toList.sorted mustEqual ps.sorted
          }
      }
    }
  }
}
```

Testing the loading of all products if none exit is trivial like the one for a non existing single product. For the case of multiple products we generate a list of them which we save. Afterwards we load them and use the same transformation logic like in the routes to be able to construct proper `Product` instances. One thing you might notice is the explicit sorting which is due to the fact that we want to ensure that our product lists are both sorted before comparing them.

{caption: "Repository test: saveProduct"}
```scala
"#saveProduct" when {
  "the product does not already exist" must {
    "save the product to the database" in {
      genProduct.sample match {
        case None => fail("Could not generate data sample!")
        case Some(p) =>
          for {
            cnts <- repo.saveProduct(p)
            rows <- repo.loadProduct(p.id)
          } yield {
            withClue("Data missing from database!")(
              cnts.fold(0)(_ + _) must be(p.names.toNonEmptyList.size + 1))
            Product.fromDatabase(rows) match {
              case None => fail("No product created from database rows!")
              case Some(c) =>
                c.id must be(p.id)
                c mustEqual p
            }
          }
      }
    }
  }

  "the product does already exist" must {
    "return an error and not change the database" in {
      (genProduct.sample, genProduct.sample) match {
        case (Some(a), Some(b)) =>
          val p = b.copy(id = a.id)
          for {
            cnts <- repo.saveProduct(a)
            nosv <- repo.saveProduct(p).recover {
              case _ => 0
            }
            rows <- repo.loadProduct(a.id)
          } yield {
            withClue("Saving a duplicate product must fail!")(nosv must be(0))
            Product.fromDatabase(rows) match {
              case None => fail("No product created from database rows!")
              case Some(c) =>
                c.id must be(a.id)
                c mustEqual a
            }
          }
        case _ => fail("Could not create data sample!")
      }
    }
  }
}
```

Here we test the saving which in the first case should simply write the appropriate data into the database. If the product already exists however this should not happen. Our database constraints will ensure that this does not happen (or so we hope ;-)). Slick will throw an exception which we catch in the test code using the `recover` method from `Future` to return a zero indicating no affected database rows. In the end we test for this zero and also check if the originally saved product has not been changed.

{caption: "Repository test: updateProduct"}
```scala
"#updateProduct" when {
  "the product does exist" must {
    "update the database" in {
      (genProduct.sample, genProduct.sample) match {
        case (Some(a), Some(b)) =>
          val p = b.copy(id = a.id)
          for {
            cnts <- repo.saveProduct(a)
            upds <- repo.updateProduct(p)
            rows <- repo.loadProduct(a.id)
          } yield {
            withClue("Already existing product was not created!")(
              cnts.fold(0)(_ + _) must be(a.names.toNonEmptyList.size + 1)
            )
            Product.fromDatabase(rows) match {
              case None => fail("No product created from database rows!")
              case Some(c) =>
                c.id must be(a.id)
                c mustEqual p
            }
          }
        case _ => fail("Could not create data sample!")
      }
    }
  }

  "the product does not exist" must {
    "return an error and not change the database" in {
      genProduct.sample match {
        case None => fail("Could not generate data sample!")
        case Some(p) =>
          for {
            nosv <- repo.updateProduct(p).recover {
              case _ => 0
            }
            rows <- repo.loadProduct(p.id)
          } yield {
            withClue("Updating a not existing product must fail!")
              (nosv must be(0))
            withClue("Product must not exist in database!")
              (rows must be(empty))
          }
      }
    }
  }
}
```

For testing an update we generate two samples, save one to the database, change the id of the other to the one from the first and execute an update. This update should proceed without problems and the data in the database must have been changed correctly.
If the product does not exist then we use the same `recover` technique like in the `saveProduct` test.

Congratulations, we have made a check mark on our first integration test using a real database using randomly generated data!

#### Testing the routes

Regarding the route testing there several options as always. For this one we will define some use cases and then develop some more helper code which will allow us to fire up our routes and do real HTTP requests and then check the database and the responses. We build upon our `BaseSpec` class and call it `BaseUseCaseSpec`. In it we will do some more things like define a global base URL which can be used from the tests to make correct requests. Additionally we will write a small actor which simply starts an Akka-HTTP server.

{caption: "An actor for starting our routes"}
```scala
final class BaseUseCaseActor(repo: Repository, mat: ActorMaterializer)
  extends Actor with ActorLogging {
  import context.dispatcher

  implicit val system: ActorSystem             = context.system
  implicit val materializer: ActorMaterializer = mat

  override def receive: Receive = {
    case BaseUseCaseActorCmds.Start =>
      val productRoutes  = new ProductRoutes(repo)
      val productsRoutes = new ProductsRoutes(repo)
      val routes         = productRoutes.routes ~ productsRoutes.routes
      val host           = context.system.settings.config.getString("api.host")
      val port           = context.system.settings.config.getInt("api.port")
      val _              = Http().bindAndHandle(routes, host, port)
    case BaseUseCaseActorCmds.Stop =>
      context.stop(self)
  }
}

object BaseUseCaseActor {
  def props(repo: Repository, mat: ActorMaterializer): Props =
    Props(new BaseUseCaseActor(repo, mat))

  sealed trait BaseUseCaseActorCmds

  object BaseUseCaseActorCmds {
    case object Start extends BaseUseCaseActorCmds
    case object Stop extends BaseUseCaseActorCmds
  }
}
```

As you can see, the actor is quite simple. Upon receiving the `Start` command it will initialise the routes and start an Akka-HTTP server. To be able to do this it needs the database repository and an actor materializer which are passed via the constructor. Regarding the `BaseUseCaseSpec` we will concentrate on the code that differs from the base class.

{caption: "Base class for use case testing"}
```scala
abstract class BaseUseCaseSpec
  extends TestKit(
    ActorSystem(
      "it-test",
      ConfigFactory
        .parseString(s"api.port=${BaseUseCaseSpec.findAvailablePort()}")
        .withFallback(ConfigFactory.load())
    )
  )
  with AsyncWordSpecLike
  with MustMatchers
  with ScalaCheckPropertyChecks
  with BeforeAndAfterAll
  with BeforeAndAfterEach {
  // ...
  final val baseUrl: String = s"""http://${system.settings.config
    .getString("api.host")}:${system.settings.config
    .getInt("api.port")}"""

  protected val dbConfig: DatabaseConfig[JdbcProfile] =
    DatabaseConfig.forConfig("database", system.settings.config)
  protected val repo = new Repository(dbConfig)

  override protected def beforeAll(): Unit = {
    val _ = flyway.migrate()
    val a = system.actorOf(BaseUseCaseActor.props(repo, materializer))
    a ! BaseUseCaseActorCmds.Start
  }
  // ...
}
```

Here we create our base URL and our database repository while we use the `beforeAll` function to initialise our actor before any test is run. Please note that this has the same drawback like sharing the repository across tests: If a test crashes your service then the others will be affected too.
But let's write a test for our first use case: loading a product!

Again we will use the `beforeEach` and `afterEach` helpers to clean up our database. Now let's take a look at a test for loading a product that does not exist.

{caption: "Use case: load a non existing product"}
```scala
"Loading a Product by ID" when {
  "the ID does not exist" must {
    val expectedStatus = StatusCodes.NotFound

    s"return $expectedStatus" in {
      val id = UUID.randomUUID

      for {
        resp <- http.singleRequest(
                  HttpRequest(
                    method = HttpMethods.GET,
                    uri = s"$baseUrl/product/$id",
                    headers = Seq(),
                    entity = HttpEntity(
                      contentType = ContentTypes.`application/json`,
                      data = ByteString("")
                    )
                  )
                )
      } yield {
        resp.status must be(expectedStatus)
      }
    }
  }
}
```

Maybe a bit verbose but we do a real HTTP request here and check the response status code. So how does it look if we run it?

```text
[info] LoadProduct:
[info] Loading a Product by ID
[info]   when the ID does not exist
[info]   - must return 404 Not Found *** FAILED ***
[info]     200 OK was not equal to 404 Not Found (LoadProduct.scala:88)
```

That is not cool. What happened? Let's take a look at the code.

```scala
get {
  complete {
    for {
      rows <- repo.loadProduct(id)
      prod <- Future { Product.fromDatabase(rows) }
    } yield prod
  }
}
```

Well, no wonder - we are simply returning the output of our `fromDatabase` helper function which may be empty. This will result in an HTTP status code 200 with an empty body. If you don't believe me just fire up the service and do a request by hand via curl or httpie.

Q> But how do we fix it?

Luckily for us Akka-HTTP has us covered with the `rejectEmptyResponse` directive which we can use.

```scala
get {
  rejectEmptyResponse {
    complete {
      for {
        rows <- repo.loadProduct(id)
        prod <- Future { Product.fromDatabase(rows) }
      } yield prod
    }
  }
}
```

Cool, it seems we're set with this one. So onward to testing to load an existing product via the API.

{caption: "Use case: load a product"}
```scala
"Loading a Product by ID" when {
  "the ID does exist" must {
    val expectedStatus = StatusCodes.OK

    s"return $expectedStatus and the Product" in {
      genProduct.sample match {
        case None => fail("Could not generate data sample!")
        case Some(p) =>
          for {
            _    <- repo.saveProduct(p)
            rows <- repo.loadProduct(p.id)
            resp <- http.singleRequest(
                      HttpRequest(
                        method = HttpMethods.GET,
                        uri = s"$baseUrl/product/${p.id}",
                        headers = Seq(),
                        entity = HttpEntity(
                          contentType = ContentTypes.`application/json`,
                          data = ByteString("")
                        )
                      )
                    )
            body <- resp.entity.dataBytes.runFold(ByteString(""))(_ ++ _)
          } yield {
            withClue("Seeding product data failed!")(rows must not be(empty))
            resp.status must be(expectedStatus)
            decode[Product](body.utf8String) match {
              case Left(e)  => fail(s"Could not decode response: $e")
              case Right(d) => d mustEqual p
            }
          }
      }
    }
  }
}
```

Here we simple save our generated product into the database before executing our request. We also check if the product has actually been written to be on the safe side. Additionally we also check if the decoded response body matches the product we expect. In contrast to our first test this one works instantly so not all hope is lost for our coding skills. ;-)
We'll continue with the use case of saving (or creating) a product via the API. This time we will make the code snippets shorter.

{caption: "Use case: save a product (1)"}
```scala
val expectedStatus = StatusCodes.BadRequest

s"return $expectedStatus" in {
  for {
    resp <- http.singleRequest(
      HttpRequest(
        method = HttpMethods.POST,
        uri = s"$baseUrl/products",
        headers = Seq(),
        entity = HttpEntity(
          contentType = ContentTypes.`application/json`,
          data = ByteString(
            scala.util.Random.alphanumeric.take(256).mkString
          )
        )
      )
    )
  } yield {
    resp.status must be(expectedStatus)
  }
}
```

Here we test posting garbage instead of valid JSON to the endpoint which must result in a "400 Bad Request" returned to us.

{caption: "Use case: save a product (2)"}
```scala
val expectedStatus = StatusCodes.InternalServerError

s"return $expectedStatus and not save the Product" in {
  (genProduct.sample, genProduct.sample) match {
    case (Some(a), Some(b)) =>
      val p = b.copy(id = a.id)
      for {
        _    <- repo.saveProduct(a)
        rows <- repo.loadProduct(a.id)
        resp <- http.singleRequest(
          HttpRequest(
            method = HttpMethods.POST,
            uri = s"$baseUrl/products",
            headers = Seq(),
            entity = HttpEntity(
              contentType = ContentTypes.`application/json`,
              data = ByteString(p.asJson.noSpaces)
            )
          )
        )
        rows2 <- repo.loadProduct(a.id)
      } yield {
        withClue("Seeding product data failed!")(rows must not be(empty))
        resp.status must be(expectedStatus)
        Product.fromDatabase(rows2) match {
          case None    =>
            fail("Seeding product was not saved to database!")
          case Some(s) =>
            withClue("Existing product must not be changed!")(s mustEqual a)
        }
      }
    case _ => fail("Could not generate data sample!")
  }
}
```

This one executes it bit more but basically we try to save (or better create) an already existing product. Therefore the constraints of our database should product an error which in turn must return a "500 Internal Server Error" to use. Additionally we verify that the existing product in the database was not changed.

{caption: "Use case: save a product (3)"}
```scala
val expectedStatus = StatusCodes.OK

s"return $expectedStatus and save the Product" in {
  genProduct.sample match {
    case None => fail("Could not generate data sample!")
    case Some(p) =>
      for {
        resp <- http.singleRequest(
          HttpRequest(
            method = HttpMethods.POST,
            uri = s"$baseUrl/products",
            headers = Seq(),
            entity = HttpEntity(
              contentType = ContentTypes.`application/json`,
              data = ByteString(p.asJson.noSpaces)
            )
          )
        )
        rows <- repo.loadProduct(p.id)
      } yield {
        resp.status must be(expectedStatus)
        Product.fromDatabase(rows) match {
          case None    => fail("Product was not saved to database!")
          case Some(s) => s mustEqual p
        }
      }
  }
}
```

Last but not least we are testing to save a not already existing valid product into the database. Again we check for the expected status code of "200 OK" and verify that the product saved into the database is the one we sent to the API. Let's move on to testing the loading of all products now.

{caption: "Use case: load all products (1)"}
```scala
val expectedStatus = StatusCodes.OK

s"return $expectedStatus and an empty list" in {
  for {
    resp <- http.singleRequest(
              HttpRequest(
                method = HttpMethods.GET,
                uri = s"$baseUrl/products",
                headers = Seq(),
                entity = HttpEntity(
                  contentType = ContentTypes.`application/json`,
                  data = ByteString("")
                )
              )
            )
    body <- resp.entity.dataBytes.runFold(ByteString(""))(_ ++ _)
  } yield {
    resp.status must be(expectedStatus)
    decode[List[Product]](body.utf8String) match {
      case Left(e)  => fail(s"Could not decode response: $e")
      case Right(d) => d must be(empty)
    }
  }
}
```

Our first test case is loading all products if no product exists so we expect an empty list here and the appropriate status code.

{caption: "Use case: load all products (2)"}
```scala
val expectedStatus = StatusCodes.OK

s"return $expectedStatus and a list with all products" in {
  genProducts.sample match {
    case None => fail("Could not generate data sample!")
    case Some(ps) =>
      for {
        _    <- Future.sequence(ps.map(p => repo.saveProduct(p)))
        resp <- http.singleRequest(
                  HttpRequest(
                    method = HttpMethods.GET,
                    uri = s"$baseUrl/products",
                    headers = Seq(),
                    entity = HttpEntity(
                      contentType = ContentTypes.`application/json`,
                      data = ByteString("")
                    )
                  )
                )
        body <- resp.entity.dataBytes.runFold(ByteString(""))(_ ++ _)
      } yield {
        resp.status must be(expectedStatus)
        decode[List[Product]](body.utf8String) match {
          case Left(e)  => fail(s"Could not decode response: $e")
          case Right(d) => d.sorted mustEqual ps.sorted
        }
      }
  }
}
```

This one is also straight forward: We save our generated list of products to the database and query the API which must return a "200 OK" status code and a correct list of products in JSON format. Looks like we have one more use case to tackle: Updating a product via the API.

{caption: "Use case: update a product (1)"}
```scala
val expectedStatus = StatusCodes.BadRequest

s"return $expectedStatus" in {
  genProduct.sample match {
    case None => fail("Could not generate data sample!")
    case Some(p) =>
      for {
        _    <- repo.saveProduct(p)
        rows <- repo.loadProduct(p.id)
        resp <- http.singleRequest(
          HttpRequest(
            method = HttpMethods.PUT,
            uri = s"$baseUrl/product/${p.id}",
            headers = Seq(),
            entity = HttpEntity(
              contentType = ContentTypes.`application/json`,
              data = ByteString(scala.util.Random.alphanumeric.take(256).mkString)
            )
          )
        )
        rows2 <- repo.loadProduct(p.id)
      } yield {
        withClue("Seeding product data failed!")(rows must not be(empty))
        resp.status must be(expectedStatus)
        Product.fromDatabase(rows2) match {
          case None    =>
            fail("Seeding product was not saved to database!")
          case Some(s) =>
            withClue("Existing product must not be changed!")(s mustEqual p)
        }
      }
  }
```

First we test with garbage JSON in the request. Before doing the request we actually create a product to avoid getting an error caused by a possibly missing product. Afterwards we check for the expected "400 Bad Request" status code and verify that our product has not been updated.

{caption: "Use case: update product (2)"}
```scala
val expectedStatus = StatusCodes.OK

s"return $expectedStatus and update the Product" in {
  (genProduct.sample, genProduct.sample) match {
    case (Some(a), Some(b)) =>
      val p = b.copy(id = a.id)
      for {
        _    <- repo.saveProduct(a)
        rows <- repo.loadProduct(a.id)
        resp <- http.singleRequest(
          HttpRequest(
            method = HttpMethods.PUT,
            uri = s"$baseUrl/product/${p.id}",
            headers = Seq(),
            entity = HttpEntity(
              contentType = ContentTypes.`application/json`,
              data = ByteString(p.asJson.noSpaces)
            )
          )
        )
        rows2 <- repo.loadProduct(p.id)
      } yield {
        withClue("Seeding product data failed!")(rows must not be(empty))
        resp.status must be(expectedStatus)
        Product.fromDatabase(rows2) match {
          case None    => fail("Seeding product was not saved to database!")
          case Some(s) => s mustEqual p
        }
      }
    case _ => fail("Could not generate data sample!")
  }
}
```

Next we test updating an existing product using valid JSON. We check the status code and if the product has been correctly updated within the database.

{caption: "Use case: update product (3)"}
```scala
val expectedStatus = StatusCodes.InternalServerError

s"return $expectedStatus" in {
  genProduct.sample match {
    case None => fail("Could not generate data sample!")
    case Some(p) =>
      for {
        resp <- http.singleRequest(
          HttpRequest(
            method = HttpMethods.PUT,
            uri = s"$baseUrl/product/${p.id}",
            headers = Seq(),
            entity = HttpEntity(
              contentType = ContentTypes.`application/json`,
              data = ByteString(p.asJson.noSpaces)
            )
          )
        )
        rows <- repo.loadProduct(p.id)
      } yield {
        resp.status must be(expectedStatus)
        rows must be(empty)
      }
  }
}
```

Finally we test updating a non existing product which should produce the expected status code and not save into the database. Wow, it seems we done for good with our impure implementation. Well except for some benchmarking but let's save that for later.
If we look onto our test code coverage (which is a metric that you should use) then things look pretty good. We are missing some parts but in general we should have things covered.

I> Regarding the "optimal" code coverage metric... I won't give any advice here. With time you'll develop a good sense for these things and it will vary between projects depending on what you do.

## Testing the pure service

We will skip the explanation of the ScalaCheck generators because they only differ slightly from the ones used in the impure part.

### Unit Tests

The model tests are omitted here because they are basically the same as in the impure section. If you are interested in them just look at the source code. In contrast to the impure part we will now write unit tests for our routes. Meaning we will be able to test our routing logic without spinning up a database.

#### Testing our routes

To be able to test our routes we will have to implement a `TestRepository` first which we will use instead of the concrete implementation which is wired to a database.

{caption: "TestRepository implementation - take 1"}
```scala
class TestRepository[F[_]: Effect](data: Seq[Product]) extends Repository[F] {
  override def loadProduct(id: ProductId) = {
    data.find(_.id === id) match {
      case None => Seq.empty.pure[F]
      case Some(p) =>
        val ns = p.names.toNonEmptyList.toList.to[Seq]
        ns.map(n => (p.id, n.lang, n.name)).pure[F]
    }
  }

  override def loadProducts() = {
    Stream.empty
  }

  override def saveProduct(p: Product): F[Int] =
    data.find(_.id === p.id).fold(0.pure[F])(_ => 1.pure[F])

  override def updateProduct(p: Product): F[Int] =
    data.find(_.id === p.id).fold(0.pure[F])(_ => 1.pure[F])

}
```

As you can see we try to stay abstract (using our HKT `F[_]` here) and we have basically left out the implementation of `loadProducts` because it will just return an empty stream. We will get back to it later on. Aside from that the class can be initialised with a (potentially empty) list of `Product` entities which will be used as a "database". The save and update functions won't change any data, they will just return a `0` or a `1` depending on the product being present in the seed data list.

{caption: "Unit test: Product routes (1)"}
```scala
val emptyRepository: Repository[IO] = new TestRepository[IO](Seq.empty)
val expectedStatusCode = Status.NotFound

s"return $expectedStatusCode" in {
  forAll("id") { id: ProductId =>
    Uri.fromString("/product/" + id.toString) match {
      case Left(_) => fail("Could not generate valid URI!")
      case Right(u) =>
        def service: HttpRoutes[IO] =
          Router("/" -> new ProductRoutes(emptyRepository).routes)
        val response: IO[Response[IO]] = service.orNotFound.run(
          Request(method = Method.GET, uri = u)
        )
        val result = response.unsafeRunSync
        result.status must be(expectedStatusCode)
        result.body.compile.toVector.unsafeRunSync must be(empty)
    }
  }
}
```

Above you can see the test for querying a non existing product which must return an empty response using a "404 Not Found" status code. First we try to create a valid URI from our generated `ProductId`. If that succeeds we create a small service wrapper for our routes in which we inject our empty `TestRepository`. Finally we create a response using this service and a request that we construct. Because we are in the land of `IO` we have to actually execute it (via `unsafeRunSync`) to get any results back. Finally we validate the status code and the response body.

Q> But what do we have here?

```text
[info]   when GET /product/ID
[info]     when product does not exist
[info]     - must return 404 Not Found *** FAILED ***
[info]       TestFailedException was thrown during property evaluation.
[info]         Message: 200 OK was not equal to 404 Not Found
[info]         Location: (ProductRoutesTest.scala:46)
[info]         Occurred when passed generated values (
[info]           id = 3f298ae4-4f7b-415b-9888-c2e9b34a4883
[info]         )
```

It seems that we just pass an empty response if we do not find the product. This is not nice, so let's fix this. The culprit is the following line in our `ProductRoutes` file:

```scala
for {
  // ...
  resp <- Ok(Product.fromDatabase(rows))
} yield resp
```

Okay, this looks easy. Let's try this one:

```scala
for {
  // ...
  resp <- Product.fromDatabase(rows).fold(NotFound())(p => Ok(p))
} yield resp
```

Oh no, the compiler complains:

```text
Cannot convert from Product to an Entity, because no 
  EntityEncoder[F, com.wegtam.books.pfhais.pure.models.Product] 
  instance could be found.
```

Right, before we had an `Option[Product]` here for which we created an implicit JSON encoder. So if we create one for the `Product` itself then we should be fine.

```scala
implicit def encodeProduct[A[_]: Applicative]: EntityEncoder[A, Product] = 
  jsonEncoderOf
```

Now back to our test:

```text
[info]   when GET /product/ID
[info]     when product does not exist
[info]     - must return 404 Not Found
```

Great! Seems like we are doing fine, so let's continue. Next in line is testing a query for an existing product.

{caption: "Unit test: Product routes (2)"}
```scala
implicit def decodeProduct: EntityDecoder[IO, Product] = jsonOf
val expectedStatusCode = Status.Ok

s"return $expectedStatusCode and the product" in {
  forAll("product") { p: Product =>
    Uri.fromString("/product/" + p.id.toString) match {
      case Left(_) => fail("Could not generate valid URI!")
      case Right(u) =>
        val repo: Repository[IO] = new TestRepository[IO](Seq(p))
        def service: HttpRoutes[IO] =
          Router("/" -> new ProductRoutes(repo).routes)
        val response: IO[Response[IO]] = service.orNotFound.run(
          Request(method = Method.GET, uri = u)
        )
        val result = response.unsafeRunSync
        result.status must be(expectedStatusCode)
        result.as[Product].unsafeRunSync must be(p)
    }
  }
}
```

This time we generate a whole product, again try to create a valid URI and continue as before. But this time we inject our `TestRepository` containing a list with our generated product. In the end we test our expected status code and the response body must contain our product. For the last part to work we must have an implicit `EntityDecoder` in scope.

{caption: "Unit test: Product routes (3)"}
```scala
val expectedStatusCode = Status.BadRequest

s"return $expectedStatusCode" in {
  forAll("id") { id: ProductId =>
    Uri.fromString("/product/" + id.toString) match {
      case Left(_) => fail("Could not generate valid URI!")
      case Right(u) =>
        def service: HttpRoutes[IO] =
          Router("/" -> new ProductRoutes(emptyRepository).routes)
        val payload = scala.util.Random.alphanumeric.take(256).mkString
        val response: IO[Response[IO]] = service.orNotFound.run(
          Request(method = Method.PUT, uri = u)
            .withEntity(payload.asJson.noSpaces)
        )
        val result = response.unsafeRunSync
        result.status must be(expectedStatusCode)
        result.body.compile.toVector.unsafeRunSync must be(empty)
    }
  }
}
```

Here we are trying to update a product which doesn't have to exist because we send totally garbage JSON with the request which should result in a "400 Bad Request" status code. However if we run our test we get an exception instead:

```text
[info]   when PUT /product/ID
[info]     when request body is invalid
[info]     - must return 400 Bad Request *** FAILED ***
[info]       InvalidMessageBodyFailure was thrown during property
[info]         Occurred when passed generated values (
[info]           id = 932682c9-1f9a-463a-84db-a0992d466aa3
[info]         )
```

So let's take a deep breath and look at our code:

```scala
case req @ PUT -> Root / "product" / UUIDVar(id) =>
  for {
    p <- req.as[Product]
    _ <- repo.updateProduct(p)
    r <- NoContent()
  } yield r
```

As we can see we do no error handling at all. So maybe we can rewrite this a little bit.

```scala
case req @ PUT -> Root / "product" / UUIDVar(id) =>
  req
    .as[Product]
    .flatMap { p =>
      repo.updateProduct(p) *> NoContent()
    }
    .handleErrorWith {
      case InvalidMessageBodyFailure(_, _) => BadRequest()
    }
```

Now we explicitly handle any error which occurs when decoding the request entity. But in fact: I am lying to you. We only handle the invalid message body failure here. On the other hand it is enough to make our test happy. :-)

I> In case you are wondering what the `*>` operator means, here a short (hopefully not wrong) explanation:
I> The operator is defined on `Apply` in Cats and in our (monadic) context it is a shorter way for writing `repo.updateProduct(p).flatMap(_ => NoContent())`.

Onwards to our next test cases in which we use a valid JSON payload for our request.

{caption: "Unit test: Product routes (4)"}
```scala
val expectedStatusCode = Status.NotFound

s"return $expectedStatusCode" in {
  forAll("product") { p: Product =>
    Uri.fromString("/product/" + p.id.toString) match {
      case Left(_) => fail("Could not generate valid URI!")
      case Right(u) =>
        def service: HttpRoutes[IO] =
          Router("/" -> new ProductRoutes(emptyRepository).routes)
        val response: IO[Response[IO]] = service.orNotFound.run(
          Request(method = Method.PUT, uri = u)
            .withEntity(p)
        )
        val result = response.unsafeRunSync
        result.status must be(expectedStatusCode)
        result.body.compile.toVector.unsafeRunSync must be(empty)
    }
  }
}
```

We expect a "404 Not Found" if we try to update a valid product which does not exist. But what do we get in the tests?

```text
Message: 204 No Content was not equal to 404 Not Found
```

Well not exactly what we planned for but it is our own fault. We used the `*>` operator which ignores the value from the previous operation. So we need to fix that.

```scala
case req @ PUT -> Root / "product" / UUIDVar(id) =>
  req
    .as[Product]
    .flatMap { p =>
      for {
        cnt <- repo.updateProduct(p)
        res <- cnt match {
          case 0 => NotFound()
          case _ => NoContent()
        }
      } yield res
    }
    .handleErrorWith {
      case InvalidMessageBodyFailure(_, _) => BadRequest()
    }
```

We rely on the return value of our update function which contains the number of affected database rows. If it is zero then nothing has been done implying that the product was not found. Otherwise we return our "204 No Content" response as before. Still we miss one last test for our product routes.

{caption: "Unit test: Product routes (5)"}
```scala
val expectedStatusCode = Status.NoContent

s"return $expectedStatusCode" in {
  forAll("product") { p: Product =>
    Uri.fromString("/product/" + p.id.toString) match {
      case Left(_) => fail("Could not generate valid URI!")
      case Right(u) =>
        val repo: Repository[IO] = new TestRepository[IO](Seq(p))
        def service: HttpRoutes[IO] =
          Router("/" -> new ProductRoutes(repo).routes)
        val response: IO[Response[IO]] = service.orNotFound.run(
          Request(method = Method.PUT, uri = u)
            .withEntity(p)
        )
        val result = response.unsafeRunSync
        result.status must be(expectedStatusCode)
        result.body.compile.toVector.unsafeRunSync must be(empty)
    }
  }
}
```

Basically this is the same test as before with the exception that we now give our routes a properly seeded test repository. Great, we have tested our `ProductRoutes` and without having to spin up a database! But we still have work to do, so let's move on to testing the `ProductsRoutes` implementation. Before we do that we adapt the code for creating a product using our gained knowledge from our update test.

{caption: "ProductsRoutes: adapted create endpoint"}
```scala
case req @ POST -> Root / "products" =>
  req
    .as[Product]
    .flatMap { p =>
      for {
        cnt <- repo.saveProduct(p)
        res <- cnt match {
          case 0 => NotFound()
          case _ => InternalServerError()
        }
      } yield res
    }
    .handleErrorWith {
      case InvalidMessageBodyFailure(_, _) => BadRequest()
    }
```

Now to our tests, we will start with sending garbage JSON via the POST request.

{caption: "Unit test: Products routes (1)"}
```scala
val expectedStatusCode = Status.BadRequest

s"return $expectedStatusCode" in {
  def service: HttpRoutes[IO] =
    Router("/" -> new ProductsRoutes(emptyRepository).routes)
  val payload = scala.util.Random.alphanumeric.take(256).mkString
  val response: IO[Response[IO]] = service.orNotFound.run(
    Request(method = Method.POST, uri = Uri.uri("/products"))
      .withEntity(payload.asJson.noSpaces)
  )
  val result = response.unsafeRunSync
  result.status must be(expectedStatusCode)
  result.body.compile.toVector.unsafeRunSync must be(empty)
}
```

There is nothing special here, the test is same as for the `ProductRoutes` except for the changed URI and HTTP method. Also the code is a bit simpler because we do not need to generate a dynamic request URI like before.

{caption: "Unit test: Products routes (2)"}
```scala
val expectedStatusCode = Status.NoContent

s"return $expectedStatusCode" in {
  forAll("product") { p: Product =>
    val repo: Repository[IO] = new TestRepository[IO](Seq(p))
    def service: HttpRoutes[IO] =
      Router("/" -> new ProductsRoutes(repo).routes)
    val response: IO[Response[IO]] = service.orNotFound.run(
      Request(method = Method.POST, uri = Uri.uri("/products"))
        .withEntity(p)
    )
    val result = response.unsafeRunSync
    result.status must be(expectedStatusCode)
    result.body.compile.toVector.unsafeRunSync must be(empty)
  }
}
```

Saving a product using valid JSON payload should succeed and in fact it does because of the code we have in our `TestRepository` instance. If you remember we use the following code for `saveProduct`:

```scala
override def saveProduct(p: Product): F[Int] =
  data.find(_.id === p.id).fold(0.pure[F])(_ => 1.pure[F])
```

This code will return a `0` if the product we try to save does not exist in the seed data set and only a `1` if it can be found within aforementioned set. This code clearly doesn't make any sense except for our testing. This way we can ensure the behaviour of the save function without having to create a new `Repository` instance with hard coded behaviour. :-)

{caption: "Unit test: Products routes (3)"}
```scala
val expectedStatusCode = Status.InternalServerError

s"return $expectedStatusCode" in {
  forAll("product") { p: Product =>
    def service: HttpRoutes[IO] =
      Router("/" -> new ProductsRoutes(emptyRepository).routes)
    val response: IO[Response[IO]] = service.orNotFound.run(
      Request(method = Method.POST, uri = Uri.uri("/products"))
        .withEntity(p)
    )
    val result = response.unsafeRunSync
    result.status must be(expectedStatusCode)
    result.body.compile.toVector.unsafeRunSync must be(empty)
  }
}
```

We use the empty repository this time to ensure that the `saveProduct` function will return a zero, triggering the desired logic in our endpoint. Almost done, so let's check the endpoint for returning all products.

{caption: "Unit test: Products routes (4)"}
```scala
val expectedStatusCode = Status.Ok

s"return $expectedStatusCode and an empty list" in {
  def service: HttpRoutes[IO] =
    Router("/" -> new ProductsRoutes(emptyRepository).routes)
  val response: IO[Response[IO]] = service.orNotFound.run(
    Request(method = Method.GET, uri = Uri.uri("/products"))
  )
  val result = response.unsafeRunSync
  result.status must be(expectedStatusCode)
  result.as[List[Product]].unsafeRunSync mustEqual List.empty[Product]
}
```

We simply expect an empty list if no products exist. It is as simple as that and works right out of the box. Last but not least we need to test the return of existing products. But before we do this let's take a look at our `TestRepository` implementation.

{caption: "TestRepository: stubbed loadProducts"}
```scala
override def loadProducts() = Stream.empty
```

Uh, oh, that does not bode well! So we will need to fix that first. Because we were wise to chose fs2 as our streaming library of choice the solution is as simple as this.

{caption: "TestRepository: fixed loadProducts"}
```scala
override def loadProducts() = {
  val rows = data.flatMap { p =>
    val ns = p.names.toNonEmptyList.toList.to[Seq]
    ns.map(n => (p.id, n.lang, n.name))
  }
  Stream.emits(rows)
}
```

Now we can write our last test.

{caption: "Unit test: Products routes (5)"}
```scala
implicit def decodeProducts: EntityDecoder[IO, List[Product]] = jsonOf
val expectedStatusCode = Status.Ok

s"return $expectedStatusCode and a list of products" in {
  forAll("products") { ps: List[Product] =>
    val repo: Repository[IO] = new TestRepository[IO](ps)
    def service: HttpRoutes[IO] =
      Router("/" -> new ProductsRoutes(repo).routes)
    val response: IO[Response[IO]] = service.orNotFound.run(
      Request(method = Method.GET, uri = Uri.uri("/products"))
    )
    val result = response.unsafeRunSync
    result.status must be(expectedStatusCode)
    result.as[List[Product]].unsafeRunSync mustEqual ps
  }
}
```

To decode the response correctly an implicit `EntityDecoder` of the appropriate type is needed in scope. But the rest of the test should look pretty familiar to you by now.

Q> So what do have left to do?

It seems the only parts left to test are the `FlywayDatabaseMigrator` and our `DoobieRepository` classes. Testing them will require a running database so we are leaving the cosy world of unit tests behind and venture forth into integration test land. But fear not, we already have some - albeit impure - experience here.

### Integration Tests

As usual we start up by implementing a base class that we can use to provide common settings and functions across our tests.

{caption: "BaseSpec for pure integration tests"}
```scala
abstract class BaseSpec extends WordSpec 
    with MustMatchers
    with ScalaCheckPropertyChecks
    with BeforeAndAfterAll
    with BeforeAndAfterEach {

  protected val config = ConfigFactory.load()
  protected val dbConfig = loadConfig[DatabaseConfig](config, "database")

  override def beforeAll(): Unit = {
    val _ = withClue("Database configuration could not be loaded!") {
      dbConfig.isRight must be(true)
    }
  }
}
```

You can see that we keep it simple here and only load the database configuration and ensure that is has been indeed loaded correctly in the `beforeAll` function.

#### Testing the FlywayDatabaseMigrator

To ensure the basic behaviour of our `FlywayDatabaseMigrator` we write a simple test.

{caption: "Integration test: database migrator (1)"}
```scala
"the database is not available" must {
  "throw an exception" in {
    val cfg = DatabaseConfig(
      driver = "This is no driver name!",
      url = "jdbc://some.host/whatever",
      user = "no-user",
      pass = "no-password"
    )
    val migrator: DatabaseMigrator[IO] = new FlywayDatabaseMigrator
    val program = migrator.migrate(cfg.url, cfg.user, cfg.pass)
    an[FlywayException] must be thrownBy program.unsafeRunSync
  }
}
```

Within this test we construct an invalid database configuration and expect that the call to `migrate` throws an exception. If you remember, we had this issue already and chose not to handle any exceptions but let the calling site do this - for example via a `MonadError` instance.

{caption: "Integration test: database migrator (2)"}
```scala
dbConfig.map { cfg =>
  val migrator: DatabaseMigrator[IO] = new FlywayDatabaseMigrator
  val program = migrator.migrate(cfg.url, cfg.user, cfg.pass)
  program.unsafeRunSync must be > 0
}
// ---
dbConfig.map { cfg =>
  val migrator: DatabaseMigrator[IO] = new FlywayDatabaseMigrator
  val program = migrator.migrate(cfg.url, cfg.user, cfg.pass)
  val _ = program.unsafeRunSync
  program.unsafeRunSync must be(0)
}
```

The other two tests are also quite simple, we just expect it to return either zero or the number of applied migrations depending on the state of the database. It goes without saying that we of course use the `beforeEach` and `afterEach` helpers within the test to prepare and clean our database properly.

Last but not least we take a look at testing our actual repository implementation which uses Doobie. To avoid trouble we need to define a globally available `ContextShift` in our test which is as simple as this:

```scala
implicit val cs = IO.contextShift(ExecutionContexts.synchronous)
```

Now we can start writing our tests.

{caption: "Integration test: repository (1)"}
```scala
val tx = Transactor
  .fromDriverManager[IO](c.driver, c.url, c.user, c.pass)
val repo = new DoobieRepository(tx)
forAll("ID") { id: ProductId =>
  for {
    rows <- repo.loadProduct(id)
  } yield {
    rows must be(empty)
  }
}
```

Here we simply test that the `loadProduct` function returns an empty list if the requested product does not exist in the database.

{caption: "Integration test: repository (2)"}
```scala
forAll("product") { p: Product =>
  for {
    _    <- repo.saveProduct(p)
    rows <- repo.loadProduct(p.id)
  } yield {
    rows must not be(empty)
    Product.fromDatabase(rows) must contain(p)
  }
}
```

From now on we'll omit the transactor and repository creation from the code examples. As you can see a generated product is saved to the database and loaded again and verified in the end.

{caption: "Integration test: repository (3)"}
```scala
val rows = repo.loadProducts().compile.toList
rows.unsafeRunSync must be(empty)
```

Testing that `loadProducts` returns an empty stream if no products exist is as simple as the code above. :-)

{caption: "Integration test: repository (4)"}
```scala
forAll("products") { ps: List[Product] =>
  for {
    _    <- ps.traverse(repo.saveProduct)
    rows = repo.loadProducts()
      .groupAdjacentBy(_._1)
      .map {
        case (id, rows) => Product.fromDatabase(rows.toList)
      }
      .collect {
        case Some(p) => p
      }
      .compile
      .toList
  } yield {
    val products = rows.unsafeRunSync
    products must not be(empty)
    products mustEqual ps
  }
}
```

In contrast the test code for checking the return of existing products is a bit more involving. But let's step through it together. First we save the list of generated products to the database which we do using the `traverse` function provided by Cats. In impure land we used `Future.sequence` here if you remember - but now we want to stay pure. ;-)
Next we call our `loadProducts` function and apply a part of the logic from our `ProductsRoutes` to it, namely we construct a proper stream of products which we turn into a list via `compile` and `list` in the end. Finally we check that the list is not empty and equal to our generated list.

{caption: "Integration test: repository (5)"}
```scala
forAll("product") { p: Product =>
  for {
    cnt  <- repo.saveProduct(p)
    rows <- repo.loadProduct(p.id)
  } yield {
    cnt must be > 0
    rows must not be(empty)
    Product.fromDatabase(rows) must contain(p)
  }
}
```

The code for testing `saveProduct` is nearly identical to the `loadProduct` test as you can see. We simply check additionally that the function returns the number of affected database rows.

{caption: "Integration test: repository (6)"}
```scala
forAll("product") { p: Product =>
  for {
    cnt  <- repo.updateProduct(p)
    rows <- repo.loadProduct(p.id)
  } yield {
    cnt must be(0)
    rows must be(empty)
  }
}
```

Updating a non existing product must return a zero and save nothing to the database, which is what we test above.

{caption: "Integration test: repository (7)"}
```scala
forAll("productA", "productB") { (a: Product, b: Product) =>
  val p = b.copy(id = a.id)
  for {
    _    <- repo.saveProduct(a)
    cnt  <- repo.updateProduct(p)
    rows <- repo.loadProduct(p.id)
  } yield {
    cnt must be > 0
    rows must not be(empty)
    Product.fromDatabase(rows) must contain(p)
  }
}
```

Finally we test updating a concrete product by generating two of them, saving the first into the database and running an update using the second with the id from the first.

Wow, it seems we are finished! Congratulations, we can now check mark the point "write a pure http service in Scala" on our list. :-)

X> Please feel free to implement some complete integration tests (like in the impure section) against the API as an exercise.

# Adding benchmarks

Now that we have our implementations in place we can start comparing them. We will start with implementing some benchmarks to test the performance of both implementations.

I> Please do not confuse a benchmark with a load test. While the latter is intended to push a system or application to its limits, the former is intended to gather performance statistics for a specified set of conditions.

There are several applications available to perform load tests and benchmarks. Regarding the latter the Apache JMeter[^25] project is a good starting point. It is quite easy to get something running. Like the documentation says: For the real stuff you should only use the command line application and use the GUI to create and test your benchmark.

We'll skip a long introduction and tutorial for JMeter because you can find a lot within the documentation and there are lots of tutorials online.

## Our environment

Within the book repository you'll find a folder named `jmeter` it contains several things:

1. Several files ending with `.jmx` like `Pure-Create-Products.jmx` and so on.
2. A CSV file containing 100.000 valid product IDs named `product-ids.csv`.
3. A file named `benchmarks.md`.

The `.jmx` files are the configuration files for JMeter which can be used to run the benchmarks. They are hopefully named understandable and are expected to be run in the following order:

1. Create products
2. Load products
3. Update products
4. Load all products

I> Please note that you should really run the service on another machine! Therefore you will have to adapt the HTTP request component in the benchmarks which defaults to `localhost`.

The file `product-ids.csv` is expected in the `/tmp` folder, so you'll have to copy it there or adjust the benchmark configurations. Finally the file `benchmarks.md` holds detailed information about the benchmark runs (each one was done three times in a row).

### System environment

Service and testing software (Apache JMeter) were run on different workstations connected via 100 MBit/s network connection.

#### Service workstation

| CPU | Core i5-9600K, 6 Cores, 3,7 GHz    |
| RAM | 32 GB                              |
| HDD | 2x Samsung SSD 860 PRO 512GB, SATA |
| OS  | FreeBSD 12 (HT disabled)           |
| JDK | 11.0.4+11-2                        |
| DB  | PostgreSQL 11.3                    |

#### Client workstation

| CPU | AMD Ryzen Threadripper 2950X      |
| RAM | 32 GB                             |
| HDD | 2x Samsung SSD 970 PRO 512GB, M.2 |
| OS  | FreeBSD 12 (HT disabled)          |
| JDK | 11.0.4+11-2                       |

Apache JMeter version 5.1.1 was used to run the benchmark and if not noted otherwise 10 threads were used with a 10 seconds ramp up time for each benchmark.

## Comparison

So let's start with comparing the results. As mentioned more details can be found in the file `benchmarks.md`. We'll stick to using the average of the metrics across all three benchmark runs. The following abbreviations will be used in the tables and legends.

AVG
: The average response time in milli seconds.

MED
: The median response time in milli seconds.

90%
: 90 percent of all requests were handled within the response time in milli seconds or less.

95%
: 95 percent of all requests were handled within the response time in milli seconds or less.

99%
: 99 percent of all requests were handled within the response time in milli seconds or less.

MIN
: The minium response time in milli seconds.

MAX
: The maximum response time in milli seconds.

ERR
: The error rate in percent.

R/S
: The number of requests per second that could be handled.

MEM
: The maximum amount of memory used by the service during the benchmark in MB.

LD
: The average system load on service machine during the benchmark.

### Create 100.000 products

| Metric | Impure  | Pure    |
|--------|---------|---------|
| AVG    |   98    |   12    |
| MED    |   95    |   11    |
| 90%    |  129    |   15    |
| 95%    |  143    |   18    |
| 99%    |  172    |   30    |
| MIN    |   53    |    5    |
| MAX    | 1288    |  675    |
| ERR    |    0%   |    0%   |
| R/S    |  100.56 |  765.33 |
| MEM    | 1158    | 1308    |
|  LD    |   16    |    9    |

Wow, I honestly have to say that I didn't expect that. Usually the world has come to believe that the *impure* approach might be dirty but is definitely always faster. Well it seems we're about to correct that. I don't know about you but I'm totally fine with that. ;-)
But now let's break it apart piece by piece. The first thing that catches the eye is that the pure service seems to be about seven times faster than the impure one! The average 100 requests per second on the impure side stand against an average 765 requests per second on the pure side. Also the metrics regarding the response times support that. Regarding the memory usage we can see that the pure service needed about 13% more memory than the impure one. Living in times in which memory is cheap I consider this a small price to pay for a significant performance boost.
Last but not least I found it very interesting that the average system load was much higher (nearly twice as high) in the impure implementation. While it is okay to make use of your resources a lower utilisation allows more "breathing room" for other tasks (operating system, database, etc.).

### Load 100.000 products

| Metric | Impure  | Pure    |
|--------|---------|---------|
| AVG    |    7    |    7    |
| MED    |    8    |    7    |
| 90%    |   10    |    9    |
| 95%    |   11    |   10    |
| 99%    |   14    |   19    |
| MIN    |    4    |    2    |
| MAX    |  347    |  118    |
| ERR    |    0%   |    0%   |
| R/S    | 1162.20 | 1248.63 |
| MEM    | 1449    | 1538    |
|  LD    |   13    |    8    |

The loading benchmark provides a more balanced picture. While the pure service is still slightly ahead (about 7% faster), it uses about 6% more memory than the impure one. Overall both implementations deliver nearly the same results. But again the pure one causes significant lower system load like in the first benchmark.

### Update 100.000 products

| Metric | Impure  | Pure    |
|--------|---------|---------|
| AVG    |   78    |   12    |
| MED    |   75    |   11    |
| 90%    |  104    |   16    |
| 95%    |  115    |   20    |
| 99%    |  140    |   34    |
| MIN    |   42    |    5    |
| MAX    |  798    |  707    |
| ERR    |    0%   |    0%   |
| R/S    |  125.66 |  765.26 |
| MEM    | 1176    | 1279    |
|  LD    |   16    |    8    |

Updating existing products results in nearly the same picture as the "create products" benchmark. Interestingly the impure service performs about 20% better on an update than on a create. I have no idea why but it caught my eye. The other metrics are as said nearly identical to the first benchmark. The pure service uses a bit more memory (around 8%) but is around 6 times faster than the impure one causing only half of the system load.

I> During the runs I encountered occasionally errors with the pure service but I was unable to reproduce them. For posterity I created a ticket on the http4s project[^26] and also noted the error messages in the file `benchmarks.md`.

### Bulk load all 100.000 products

For our last benchmark we load all existing products via the `GET /products` route. Because this causes a lot of load we reduce the number of threads in our JMeter configuration from 10 to 2 and only use 50 iterations. But enough talk here are the numbers.

| Metric | Impure  | Pure    |
|--------|---------|---------|
| AVG    | 19061   | 14496   |
| MED    | 19007   | 14468   |
| 90%    | 19524   | 14689   |
| 95%    | 19875   | 14775   |
| 99%    | 20360   | 14992   |
| MIN    | 17848   | 14008   |
| MAX    | 21315   | 16115   |
| ERR    |     0%  |     0%  |
| R/M    |    6.30 |    8.30 |
| MEM    |  7889   |  1190   |
|  LD    |     5   |     4   |

I> Please note that we now have requests per minute (`R/M`) instead of requests per second as before.

As you can see the difference in system load is way smaller this time. While it is still 25% a load of 4 versus 5 on a machine like the test machine makes almost no difference. However the pure service is again faster (about 25%). Looking at the memory footprint we can see that the impure one uses nearly seven times as much memory as the pure one.
But before we burst into cheers about that let's remember what we did in the impure implementation! Yes, we used the `groupBy` operator of Akka which keeps a lot of stuff in memory so the fault for this is ours. ;-)
Because I'm not in the mood to mess with Akka until we're on the memory safe side here, we'll just ignore the memory footprint for this benchmark. Summarising that the pure service is again faster than the impure one.

## Summary

Q> So what can we say after comparing our two implementations?

If you look around in the internet (and also in the literature) you'll find a lot of sources stating that "functional programming is slow" or "functional programming does not perform" and so on. Well I would argue that we have proven that this is not the case! Although we cannot generalise our findings because we only took a look at a specific niche within the corner of a specific environment, I think this is pretty exciting!

Not only do you benefit from having code that can more easily reasoned about but you gain better testing possibilities and in the end your application also performs better! :-)

While we pay some price (increased memory footprint) for it because there is no free lunch. It seems that it is worth it to work in a clean and pure fashion. So next time someone argues in favour of some dirty impure monstrosity because it is faster, just remember and tell 'em that this might not be true!

# Documenting your API

Before we celebrate ourselves we have to tackle one missing point: We have to document our API.

Q> But isn't the code documentation enough?

No, it is not! Leaving the issues of proper documented code aside here, we will concentrate on documenting the API. The de facto standard in our days seems to be using Swagger[^27] for this. To keep things simple we will stick to it. Besides that it won't hurt to have some documentation in text form (a small file could be enough) which should explain the quirks of our API. The bigger the project the earlier you may encounter flaws in the logic which might not be changeable because whatever reasons there are. ;-)

## The lay of the land

Swagger provides a bit of tooling and there are likely lots of projects trying to bring it to your favourite web framework or tool kit. In many cases it might be a good idea to bundle the Swagger UI[^28] with your service and make it available on a specific path. Depending on your needs and environment you'll want to protect that path via authentication and make it configurable for turning it off in production.

Having the UI you must decide which path you want to go down:

1. Write a `swagger.yml` file which describes your API, create JSON from it and deliver that as an asset.
2. Create the JSON dynamically via some library at runtime.

The first point has the benefit that you description will be more or less set in stone and you avoid possible performance impacts and other quirks at runtime. However you must think of a way to test that your service actually fulfils the description (*read* specification) that you deliver. The most common tool for writing your API description is probably the Swagger Editor[^29].

Taking the second path will result in a description which reflects your actual code. However none of the tools available I've seen so far has fulfilled that promise to 100 percent. You'll very likely have to make extensive use of annotations to make your API description usable, resulting also in a decoupling of code and description. Also you might encounter "funny" deduced data types like `Future1` and so on - which are annoying and confusing for the user. For those favouring the impure approach there is the swagger-akka-http library[^30].

Q> But can't we do better than this?

The answer is yes! We can describe our API using static typing and have the compiler check it and can deduce server and client code from it.

I> To be fair: Swagger is also intended to auto generate code from it but often (if not always) these are one shot throw away solutions. Because you loose your modifications if the code needs to be re-generated again.

## Using types to describe an API

Describing your API using types is not bleeding edge academic research stuff like you might have guessed. There are several libraries existing for it! :-)

Personally I stumbled upon such things first some years ago when seeing the talk "Using object algebras to design embedded DSLs" (Curry On 2016)[^31]. The related project is the library endpoints[^32]. However there are other projects too including the rho library[^33] included in the http4s project. Another one is tapir[^34] which we will be using in our example.
In the Haskell camp there is the beautiful Servant library[^35]

Q> So why did I pick the tapir library?

First I wanted to use something which allows us to generate a http4s server. This already narrowed down the options a bit. Also it should be able to generate API documentation (which nowadays means Swagger/OpenAPI support). Furthermore it should support not only http4s but more options. So after playing a bit around I decided to use the tapir library.

W> The library is still pretty young and may be subject to breaking changes. So please have this in mind when reading through the following part.

## A pure implementation using tapir.

We basically cloned our `pure` folder into the `tapir` folder and start to apply our changes to the already pure implementation. But first some theory.

### Basics

The tapir library assumes that you describe your API using the `Endpoint` type which is more concrete defined as follows: `Endpoint[I, E, O, S]`

* The type `I` defines the input given into the endpoint.
* Type type `E` defines the error (or errors) which may be returned by the endpoint.
* The type `O` defines the possible output of the endpoint.
* The type `S` specifies the type of streams which are used for in- and output.

An endpoint can have attributes like `name` or `description` which will be used in the generated documentation. You can also map input and output parameters into case classes.

I> Please note that all mappings have to be bi-directional because tapir must be able to generate server and client code from it.

Regarding the encoding and decoding of data we will need our Circe codecs but additionally some schema definitions required by tapir. In concrete we will need to define implicit `SchemaFor[T]` instances for each of our models. We will start with the `Translation` model.

{caption: "Tapir schema for Translation"}
```scala
implicit val schemaFor: SchemaFor[Translation] = SchemaFor(
  Schema.SProduct(
    Schema.SObjectInfo("Translation"),
    List(("lang", Schema.SString), ("name", Schema.SString)),
    List("lang", "name")
  )
)
```

As you can see this is quite straightforward and not very complicated. In the future we might be able to derive such things but for now we have to define them. The schema is defined as a product type which is further described by the "object info" type containing a name, the field names and their schemas and at least a list of field names which are required to construct the type.

{caption: "Tapir schema for Product (1)"}
```scala
implicit val schemaFor: SchemaFor[Product] = SchemaFor(
  Schema.SProduct(
    Schema.SObjectInfo("Product"),
    List(
      ("id", Schema.SString),
      ("names", Schema.SArray(Translation.schemaFor.schema))
    ),
    List("id", "names")
  )
)
```

This is basically the same thing as before except that we rely on the existing schema definition of `Translation` and use that here. You might notice that we explicitly define our `NonEmptySet` as an `SArray` here. This is because we want a list like representation on the JSON side.

Q> But can we generalise this some more?

Yes, we can! :-) To gain more flexibility we can provide a generic schema for our `NonEmptySet` type.

{caption: "Tapir schema for NonEmptySet from Cats"}
```scala
implicit def schemaForNeS[T](implicit a: SchemaFor[T]): 
  SchemaFor[NonEmptySet[T]] =
    SchemaFor(Schema.SArray(a.schema))
```

Here we define that a `NonEmptySet` will be an array using the schema of whatever type it contains. Now we rewrite our previous schema definition as follows.

{caption: "Tapir schema for Product (2)"}
```scala
implicit val schemaFor: SchemaFor[Product] = SchemaFor(
  Schema.SProduct(
    Schema.SObjectInfo("Product"),
    List(
      ("id", Schema.SString),
      ("names", schemaForNeS[Translation].schema)
    ),
    List("id", "names")
  )
)
```

It is not necessarily shorter but we have gained some more flexibility and can reuse our schema for the non empty set in several places.

### Product routes

Having the basics settled we can try to write our first endpoint. Let's refactor our product routes. We will define our endpoints in the companion object of the class.

{caption: "Tapir endpoint for loading a product"}
```scala
// Our type is Endpoint[ProductId, StatusCode, Product, Nothing]
val getProduct = endpoint.get
  .in("product" / path[ProductId]("id"))
  .errorOut(statusCode)
  .out(jsonBody[Product])
```

So what do we have here? First we specify the HTTP method by using the `get` function of the endpoint. Now we need to define our path and inputs. We do this using the `in` helper which accepts path fragments separated by slashes and also a `path[T]` helper which allows us to extract a type directly from a path fragment. This way we define our entry point `product/id` in which `id` must match our `ProductId` type.
To be able to be more flexible about our returned status codes we use the `errorOut` function which in our case just receives a status code (indicated by passing `statusCode` to it).
Finally we define that the endpoint will return the JSON representation of a product by using the `out` and `jsonBody` helpers. This all is reflected in the actual type signature of our endpoint which reads `Endpoint[ProductId, StatusCode, Product, Nothing]`. If we remember the basics then we know that this amounts to an endpoint which takes a `ProductId` as input, produces a `StatusCode` as possible error and returns a `Product` upon success.

I> But not only we know this, the compiler now knows this too! :-)

Our endpoint alone won't do us any good so we need an actual server side implementation of it. While we could have used the `serverLogic` function to directly attach our logic onto the endpoint definition this would have nailed us down to a concrete server implementation.
So we're going to implement it in the `ProductRoutes` class.

{caption: "http4s implementation of the load product endpoint"}
```scala
val getRoute: HttpRoutes[F] = ProductRoutes.getProduct.toRoutes { id =>
  for {
    rows <- repo.loadProduct(id)
    resp = Product
      .fromDatabase(rows)
      .fold(StatusCodes.NotFound.asLeft[Product])(_.asRight[StatusCode])
  } yield resp
}
```

We use the `toRoutes` helper of tapir which expects a function with the actual logic. As you can see the implementation is straightforward and only differs slightly from our original one. Currently there is no other way to handle our "not found" case than using the `fold` at the end. But if you remember, we did the same thing in the original code.

That was not that difficult, for something which some people like to talk about as "academic fantasies from fairy tale land". ;-)

Onward to our next route: updating an existing product. First we need to define our endpoint.

{caption: "Tapir endpoint for updating a product"}
```scala
// Our type is Endpoint[(ProductId, Product), StatusCode, Unit, Nothing]
val updateProduct =
  endpoint.put
    .in("product" / path[ProductId]("id"))
    .in(
      jsonBody[Product]
        .description("The updated product data which should be saved.")
    )
    .errorOut(statusCode)
    .out(statusCode(StatusCodes.NoContent))
```

This is only slightly more code than our first endpoint. We use the `put` method this time and the same logic as before to extract our product id from the path. But we also need our product input which we expect as JSON in the request body. The `jsonBody` function used is also extended with the `description` helper here which will provide data for a possibly generated documentation. We'll come to generated API docs later on.
We also restrict our errors to status codes via the `errorOut(statusCode)` directive. Last but not least we have to define our output. Per default a status code of "200 OK" will be used which is why we override it in the `out` function with the "204 No Content" preferred by us.

{caption: "http4s implementation of the update product endpoint"}
```scala
private val updateRoute: HttpRoutes[F] = 
  ProductRoutes.updateProduct.toRoutes {
    case (id, p) =>
      for {
        cnt <- repo.updateProduct(p)
        res = cnt match {
          case 0 => StatusCodes.NotFound.asLeft[Unit]
          case _ => ().asRight[StatusCode]
        }
      } yield res
  }
```

The implementation is again very similar to our original one. Except that it is even a bit simpler. This is because we do not have to worry about wrongly encoded input (Remember our `handleErrorWith` directive?). The tapir library will by default return a "400 Bad Request" status if any provided input cannot be decoded.
Within the pattern match we use the status codes provided by tapir and map the returned values to the correct type which is an `Either[StatusCode, Unit]` because of our endpoint type. This results from our endpoint type signature being `Endpoint[(ProductId, Product), StatusCode, Unit, Nothing]`. This translates to having an input of both a `ProductId` and a `Product` and returning a `StatusCode` in the error case or `Unit` upon success.

Now we only need to combine both routes and we're set.

{caption: "combined product routes"}
```scala
@SuppressWarnings(Array("org.wartremover.warts.Any"))
val routes: HttpRoutes[F] = getRoute <+> updateRoute
```

So, let us run our tests and see what happens.

```text
[info]   when PUT /product/ID
[info]     when request body is invalid
[info]     - must return 400 Bad Request *** FAILED ***
[info]       TestFailedException was thrown during property evaluation.
[info]         Message: Vector(...) was not empty
[info]         Location: (ProductRoutesTest.scala:100)
[info]         Occurred when passed generated values (
[info]           id = b55df341-a165-40c4-87ba-3d1c5cfb2f0c
[info]         )
```

Well, not what we expected, or is it? To be honest I personally expected more errors but maybe I'm just doing this stuff for too long. ;-)
If we look into the error we find that because the encoding problems are now handled for us the response not only contains a status code of "400 Bad Request" but also an error message: "Invalid value for: body". Because I'm fine with that I just adjust the test and let it be good. :-)

Pretty awesome, we have already half of our endpoints done. So let's move on to the remaining ones and finally see how to generate documentation and also a client for our API.

### Products routes

{caption: "Tapir endpoint for creating a product"}
```scala
val createProduct: Endpoint[Product, StatusCode, Unit, Nothing] =
  endpoint.post
    .in("products")
    .in(
      jsonBody[Product]
        .description("The product data which should be created.")
    )
    .errorOut(statusCode)
    .out(statusCode(StatusCodes.NoContent))
```

As we can see the endpoint definition for creating a product does not differ from the one that was used to update one. Except that we have a different path here and do not need to extract our `ProductId` from the URL path.

{caption: "http4s implementation of the create product endpoint"}
```scala
val createRoute: HttpRoutes[F] =
  ProductsRoutes.createProduct.toRoutes { product =>
    for {
      cnt <- repo.saveProduct(product)
      res = cnt match {
        case 0 => StatusCodes.InternalServerError.asLeft[Unit]
        case _ => ().asRight[StatusCode]
      }
    } yield res
  }
```

The implementation is again pretty simple. In case that the `saveProduct` function returns a zero we output a "500 Internal Server Error" because the product has not been saved into the database.

Finally we have our streaming endpoint left, so let's see how we can do this via tapir.

{caption: "Tapir endpoint for loading all products"}
```scala
// Our type is Endpoint[Unit, StatusCode, Stream[F, Byte], Stream[F, Byte]]
def getProducts[F[_]] =
  endpoint.get
    .in("products")
    .errorOut(statusCode)
    .out(
      streamBody[Stream[F, Byte]](schemaFor[Byte], tapir.MediaType.Json())
    )
```

The first thing we can see is that we use a `def` instead of a `val` this time. This is caused by some necessities on the Scala side. If we want to abstract over a type parameter then we need to use a `def` here.
We also have set the last type parameter not to `Nothing` but to something concrete this time. This is because we actually want to stream something. ;-)
It is a bit annoying that we have to define it two times (once for the output type and once for the "stream" type). Much nicer would be something like `Endpoint[I, E, Byte, Stream[F, _]]` but currently this is not the way we can do it.
So we again specify the HTTP method (via `get`) and the path (which is "products"). The `errorOut` helper once again restricts our error output to the status code. Finally we set the output of the endpoint by declaring a streaming entity (via `streamBody`).

I> Currently the only supported streaming output is `Stream[F, Byte]` so we are nailed down to just that.

But is is sufficient and we also directly specify the returned media type to be JSON.

{caption: "http4s implementation of the load all products endpoint (1)"}
```scala
@SuppressWarnings(Array("org.wartremover.warts.Any"))
val getRoute: HttpRoutes[F] = ProductsRoutes.getProducts.toRoutes {
  val prefix = Stream.eval("[".pure[F])
  val suffix = Stream.eval("]".pure[F])
  val ps = repo.loadProducts
    .groupAdjacentBy(_._1)
    .map {
      case (id, rows) => Product.fromDatabase(rows.toList)
    }
    .collect {
      case Some(p) => p
    }
    .map(_.asJson.noSpaces)
    .intersperse(",")
  val result: Stream[F, String] = prefix ++ ps ++ suffix
  val bytes: Stream[F, Byte]    = result.through(fs2.text.utf8Encode)
  bytes
}
```

Again our implementation is quite the same compared to the original one. Except that in the end we convert our stream of `String` into a stream of `Byte` using the `utf8Encode` helper from the fs2 library.

Q> So what does the compiler say to this?

```text
  found   : fs2.Stream[F,Byte]
  required: Unit => F[Either[tapir.model.StatusCode,fs2.Stream[F,Byte]]]
     (which expands to)  Unit => F[Either[Int,fs2.Stream[F,Byte]]]
     bytes
     ^
```

Damn, so close. But let's keep calm and think. Or ask around on the internet. Which is totally fine. Actually it is all in the compiler error message.

Q> So how do we convert our `Stream[F, Byte]` into an `F[Either[...]]`?

{caption: "http4s implementation of the load all products endpoint (2)"}
```scala
@SuppressWarnings(Array("org.wartremover.warts.Any"))
val getRoute: HttpRoutes[F] = ProductsRoutes.getProducts.toRoutes {
  // ...
  val result: Stream[F, String] = prefix ++ ps ++ suffix
  val bytes: Stream[F, Byte]    = result.through(fs2.text.utf8Encode)
  val response: Either[StatusCode, Stream[F, Byte]] = Right(bytes)
  (_: Unit) => response.pure[F]
}
```

We first convert our response explicitly into the right side of an `Either` because the left side is used for the error case. Afterwards we provide the needed `Unit => ...` function in which we lift our response value via `pure` into the context of `F`.
So let's go crazy and simply combine our routes like in the previous part and run the test via `testOnly *.ProductsRoutesTest` on the sbt console.

```text
[info] All tests passed.
```

Yes! Very nice, it seems like we are done with implementing our routes via tapir endpoints.

### Documentation via OpenAPI

So, we can now look at documenting our API via OpenAPI using the tooling provided by tapir. But first we should actually modify our main application entry point to provide the documentation for us.

{caption: "Provide Swagger UI and documentation"}
```scala
// ...
  productRoutes  = new ProductRoutes(repo)
  productsRoutes = new ProductsRoutes(repo)
  docs = List(
    ProductRoutes.getProduct,
    ProductRoutes.updateProduct,
    ProductsRoutes.getProducts,
    ProductsRoutes.createProduct
  ).toOpenAPI("Pure Tapir API", "1.0.0")
  docsRoutes = new SwaggerHttp4s(docs.toYaml)
  routes     = productRoutes.routes <+> productsRoutes.routes
  httpApp    = Router(
    "/" -> routes,
    "/docs" -> docsRoutes.routes
  ).orNotFound
// ...
```

We use the `toOpenAPI` helper provided by tapir which generates a class structure describing our API from a list of given endpoints. Additionally we use the `SwaggerHttp4s` helper which includes the Swagger UI for simple documentation browsing. All of it is made available under the `/docs` path. So calling `http://localhost:57344/docs` with your browser should open the UI and the correct documentation.
But while browsing there we can see that it provides our models and endpoints but documentation could be better. So what can we do about it?
The answer is simple: Use the helpers provided by tapir to add additional information to our endpoints.

#### Providing example data

Besides functions like `description` or `name` tapir also provides `example` which will result in having concrete examples in the documentation. To use this we must construct example values of the needed type. A `Product` example could look like this.

{caption: "Example Product type for the API documentation"}
```scala
val example = Product(
  id = java.util.UUID.randomUUID,
  names = NonEmptySet.one(
      Translation(
        lang = "de",
        name = "Das ist ein Name."
      )
    ) ++
    NonEmptySet.one(
      Translation(
        lang = "en",
        name = "That's a name."
      )
    ) ++
    NonEmptySet.one(
      Translation(
        lang = "es",
        name = "Ese es un nombre."
      )
    )
)
```

We can now use it in our product endpoint description.

{caption: "Documented tapir endpoints (1)"}
```scala
val getProduct = endpoint.get
  .in(
    "product" / path[ProductId]("id")
      .description("The ID of a product which is a UUID.")
      .example(example.id)
  )
  .errorOut(statusCode)
  .out(
    jsonBody[Product]
    .description("The product associated with the given ID.")
    .example(example)
  )
  .description(
    "Returns the product specified by the ID given in the URL path.
    If the product does not exist then a HTTP 404 error is returned."
  )
```

As you can see we make use of `description` and `example` here. Also the path parameter `id` is described that way.

{caption: "Documented tapir endpoints (2)"}
```scala
val updateProduct =
  endpoint.put
    .in(
      "product" / path[ProductId]("id")
        .description("The ID of a product which is a UUID.")
        .example(example.id)
    )
    .in(
      jsonBody[Product]
        .description("The updated product data which should be saved.")
        .example(example)
    )
    .errorOut(statusCode)
    .out(
      statusCode(StatusCodes.NoContent)
        .description("Upon successful product update no content is returned.")
    )
    .description(
      "Updates the product specified by the ID given in the URL path.
      The product data has to be passed encoded as JSON in the request body.
      If the product does not exist then a HTTP 404 error is returned."
    )
```

Here we also add a description to the simple status code output explaining explicitly that no content will be returned upon success. While the 204 status code should be enough to say this you can never be sure enough. ;-)
We'll skip the create endpoint because it looks nearly the same as the update endpoint. Instead let's take a look at our streaming endpoint.

{caption: "Documented tapir endpoints (3)"}
```scala
def getProducts[F[_]] =
  endpoint.get
    .in("products")
    .errorOut(statusCode)
    .out(
      streamBody[Stream[F, Byte]](schemaFor[Byte], tapir.MediaType.Json())
        .example(examples.toList.asJson.spaces2)
    )
    .description(
      "Return all existing products in JSON format as a stream of bytes."
    )
```

This time we need to provide our example as a string because of the nature (*read* type) of our endpoint. We use the non empty list of examples that we created (you can look it up in `ProductsRoutes.scala`) and convert it into a JSON string.
If we now visit our swagger endpoint we'll see nice examples included in the documentation. Pretty cool, especially because many people will look at the examples not at the specification. This might be because (too) many of us have seen an API not fulfilling its specification. This shouldn't happen in our case because we're deriving it, yeah! But nonetheless examples are very nice to have. :-)

Q> So what now?

If we take a closer look at our model descriptions then we might see that we could do better in some cases. I'm thinking of our ID fields being simple strings instead of UUIDs and the language code which is also defined as a simple string. So let's get going and clean that up!

### Refining the generated documentation

Looking at the intermediate model for our API documentation (see the `OpenAPI` class structure in the tapir library) we realise that modifying such a deeply nested case class structure might result in some really messy code. I mean we have probably all been there at some point in our life as developer. ;-)

Q> Can't we do better than this?

Yes, we can! Confronted with big and nested structures we should pick a tool from our functional programming toolbox which is called optics[^36].
Don't be scared by the name or all that mathematics, there exist some usable libraries for it. In our case we will pick Monocle[^37] which provides profunctor optics for Scala. The basic idea of optics is to provide pure functional abstractions for the manipulation of immutable objects. Because of their pure nature they are composable which results in code which is more flexible and can more easily be reasoned about.

Now that we have that cleared let's make a plan what we actually want to do.

1. Adjust the URL parameter descriptions of `{id}` to mark them as kind of `UUID`.
2. Adjust the `id` attribute of our `Product` model to mark it as kind of `UUID`.
3. Adjust the `lang` attribute of our `Translation` model to mark it as an ISO-639-1 language code.

Q> So how can we do that?

If we take a look at the code within the tapir library, we see that the `Schema` and `SchemaFor` code which is used for codecs does not yet support a dedicated `UUID` type. There is a detour for it using `Schema.SString`.

I> Currently there is active discussion about changing and extending the schema code in tapir regarding more future possibilities and better documentation options.

Now we look a bit further into the `OpenAPI` code and find that it supports several interesting attributes which we might use. For now we will stick to the attribute `pattern` of the `Schema` class in that part. It is intended to hold a pattern (*read* regular expression) which describes the format of a string type.
Okay, so we need to define some (or better exactly 2) regular expressions. But hey wait, we already have one for our language code! :-)

Q> How do we use the existing regular expression from our refined type?

Well, using some shapeless[^38] magic we might use an implicit `Witness` which should be provided by our refined type.

{caption: "Idea to reuse regular expression from refined type"}
```scala
def extractRegEx[S <: String](implicit ws: Witness.Aux[S]): String =
  ws.value
```

The code above is a rough idea so don't count on it. We'll see later on if I was right or did suffer from the hallucination of actually understanding what I am doing. ;-)
In the hope that this is settled we need one additional regular expression for a `UUID`. These are defined in RFC-4122[^39] and ignoring the special edge case of a "NIL UUID" we come up with the following solution.

{caption: "Regular expression for matching UUIDs"}
```text
^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[089ab][0-9a-f]{3}-[0-9a-f]{12}$
```

Q> What have we overlooked?

According to the OpenAPI specification we are nailed down to Javascript regular expressions (*read* the ECMA 262 regular expression dialect[^40]). Oh why cruel fate? Well, let us deal with that when we have our other puzzle pieces in order.

Before we dive right in let's play around a bit to get used to this fancy optics thing.

```scala
val docs: OpenAPI = ???
val paths: Lens[OpenAPI, ListMap[String, PathItem]] =
  GenLens[OpenAPI](_.paths)
val test = (paths composeLens at("/product/{id}")).get(d)
```

We defined our first `Lens` via the `GenLens` macro. It is supposed to give us the path definitions from an `OpenAPI` object. In the last part we use the compose functionality to query a specific item from the paths which we address via a string because it is a `ListMap` using string keys.

```text
[error] ...scala: ambiguous implicit values:
[error]  both method atMap in object At of type 
           [K, V]=> monocle.function.At[Map[K,V],K,Option[V]]
[error]  and method atSet in object At of type 
           [A]=> monocle.function.At[Set[A],A,Boolean]
[error]  match expected type monocle.function.At[S,String,A]
[error]     val x  = (paths composeLens at("/product/{id}")).get(d)
[error]                                   ^
[error] one error found
```

Oh no, the compiler yells at us! Some investigation leads to the conclusion that there is a type class instance missing for `ListMap`. So we build one. Luckily for us this is practically identical to the one for `Map`.

{caption: "At type class instance for ListMap"}
```scala
implicit def atListMap[K, V]: At[ListMap[K, V], K, Option[V]] = At(
  i => Lens((_: ListMap[K, V]).get(i))(optV => map => 
    optV.fold(map - i)(v => map + (i -> v))
  )
)
```

And now our code compiles, hooray! :-)
While we're at it we also provide an instance for `Index` on `ListMap`.

{caption: "Index type class instance for ListMap"}
```scala
implicit def listMapIndex[K, V]: Index[ListMap[K, V], K, V] = Index.fromAt
```

I> The instances have been committed to the Monocle project so chances are good that they'll be included in the next release you're using.

Okay, back to work. Thinking a bit about our problem we realise that we need a couple of lenses which we can compose to modify the needed parts of the documentation structure.

{caption: "Generating lenses"}
```scala
val paths: Lens[OpenAPI, ListMap[String, PathItem]] =
  GenLens[OpenAPI](_.paths)
val getOps: Lens[PathItem, Option[Operation]] =
  GenLens[PathItem](_.get)
val putOps: Lens[PathItem, Option[Operation]] =
  GenLens[PathItem](_.put)
val operationParams: Lens[Operation, List[OpenAPI.ReferenceOr[Parameter]]] =
  GenLens[Operation](_.parameters)
val pathParams: Lens[PathItem, List[OpenAPI.ReferenceOr[Parameter]]] =
  GenLens[PathItem](_.parameters)
val parameterSchema: Lens[Parameter, OpenAPI.ReferenceOr[Schema]] =
  GenLens[Parameter](_.schema)
val schemaPattern: Lens[Schema, Option[String]] =
  GenLens[Schema](_.pattern)
```

Well this is quite a lot but let's break it apart piece by piece. In general we use the `GenLens` macro of Monocle to create the lenses for us.
First we create a lens which returns the defined path items which is a `ListMap`. We later use the `at` function of the type class to grab a concrete entry from it. This "concrete" entry will be a `PathItem` that contains more information. Next are some lenses which will return an `Operation` from the aforementioned `PathItem`. Depending on the type of the operation (`GET`, `POST`, etc.) we return the appropriate entry.
Now we need to grab the parameters used for the endpoints which can either be collected directly from a `PathItem` or an `Operation`. These are both lists of the type `Parameter`. Okay, I'm lying straight to your face here. In fact they are `ReferenceOr[Parameter]` which means an `Either[Reference, Parameter]`. But in our use case we only have them as parameters so we'll ignore this for now.
Last but not least we need to grab the `Schema` of a parameter and from that one the `pattern` field. The schema describing the parameter is also an `Either[Reference, Schema]` which we will ignore too in this case. Now we can play around with our lenses and various combinations.

{caption: "Some examples"}
```scala
// Delete the entry at "/product/{id}"
(paths composeLens at("/product/{id}")).set(None)(docs)
// Replace the path parameters with an empty list at "/product/{id}"
(paths composeLens at("/product/{id}") composeOptional possible 
  composeLens pathParams)
    .set(List.empty)(docs)
// Traverse through all schemas in all path parameters at "/product/{id}"
(paths composeLens at("/product/{id}") composeOptional possible 
  composeLens pathParams composeTraversal each composeOptional 
  possible composeLens parameterSchema)
    .getAll(docs)
// Set the pattern field in all schemas in all path parameters
// at "/product/{id}"
(paths composeLens at("/product/{id}") composeOptional possible 
  composeLens pathParams composeTraversal each composeOptional 
  possible composeLens parameterSchema composeOptional possible 
  composeLens schemaPattern)
    .set(Option("Optics are soo cool!"))(docs)
```

This can be confusing at a first look but it is actually very powerful and clean for modifying deeply nested structures. The current API is a bit verbose but there is hope.

I> Works in in the way to greatly reduce the boilerplate in the next release of Monocle. Hopefully you can then write more straightforward code like this `paths.at("/product/{id}").field(_.parameters).each.right.field(_.schema)`.

So what we can take away from this is that we can update our `pattern` field within all parameters using the following code. Before you ask: We can update all parameters because we have only one. ;-)

{caption: "Update the pattern attribute in the API documentation"}
```scala
(paths composeLens at("/product/{id}") composeOptional possible 
  composeLens pathParams composeTraversal each composeOptional 
  possible composeLens parameterSchema composeOptional possible 
  composeLens schemaPattern)
    .set(Option("Fancy UUID regex here!"))(docs)
```

Seems we can (as good as) check off the first point on our list. Leaving us with modifying the pattern field of the actual model schemas. To get to these we have to define some more lenses.

{caption: "Additional lenses for content schemas"}
```scala
val components: Lens[OpenAPI, Option[Components]] =
  GenLens[OpenAPI](_.components)
// type Lens[Components, ListMap[String, OpenAPI.ReferenceOr[Schema]]]
val componentsSchemas =
  GenLens[Components](_.schemas)
// type Lens[Schema, ListMap[String, OpenAPI.ReferenceOr[Schema]]]
val schemaProperties =
  GenLens[Schema](_.properties)
```

The power of lenses allows us to traverse all of our structures and modify all affected models at once. So we will use the functionality provided by the `Each` type class here. Let's try something like the following code.

{caption: "Traverse each path item"}
```scala
(paths composeTraversal each composeLens getOps).getAll(docs)
```

Looks good so far but it results in a compiler error.

```text
[error] ...: diverging implicit expansion for type cats.kernel.Order[A]
[error] starting with method catsKernelStdOrderForSortedSet in trait 
        LowPrioritySortedSetInstancesBinCompat1
[error]       (paths composeTraversal each composeLens getOps).getAll(docs)
[error]                               ^
```

This looks like an error from a binary incompatible cats version. But hey, this time the compiler is lying to us. Maybe you have guessed it already: we're missing another type class instance. This time the one for `Each` which we need to traverse our `ListMap` structure. So let's write one! :-)

{caption: "Each type class instance for ListMap"}
```scala
implicit def listMapTraversal[K, V]: Traversal[ListMap[K, V], V] = 
  new Traversal[ListMap[K, V], V] {
    def modifyF[F[_]: Applicative](f: V => F[V])(s: ListMap[K, V]): 
      F[ListMap[K, V]] =
        s.foldLeft(Applicative[F].pure(ListMap.empty[K, V])) {
          case (acc, (k, v)) =>
            Applicative[F].map2(f(v), acc)((head, tail) => 
              tail + (k -> head))
      }
  }

implicit def listMapEach[K, V]: Each[ListMap[K, V], V] =
  Each(listMapTraversal)
```

As noted above these things will hopefully be in the next Monocle release together with a much nicer API. :-D
The information we need to modify is within the `components` field of the generated documentation. While we could traverse all the stuff (paths, operations) these only hold references which are of no use for us. So let's update our `Product` model.

{caption: "Update Product model description via lenses"}
```scala
(components composeOptional possible composeLens componentsSchemas 
 composeLens at("Product") composeOptional possible composeOptional 
 possible composeLens schemaProperties composeLens at("id") 
 composeOptional possible composeOptional possible composeLens 
 schemaPattern)
  .set(Option("Our UUID regex here!"))(docs)
```

This is quite a lot but we actually only instruct our optics how to traverse down the structure. In general we need to take care of our possible field types here. Due to the nature of the generated structure having a lot of `Option` and `Either` fields we need way more boilerplate here. But as mentioned it is really not that complicated. We compose our lenses via `composeLens` but may need things like `composeOptional possible` to compose on a defined `Option[T]` which we have sometimes to duplicate when having nested occurrences of these. The same instructions can be used to zoom in on the right side of an `Either`.

{caption: "Update Translation model description via lenses"}
```scala
(components composeOptional possible composeLens componentsSchemas 
 composeLens at("Translation") composeOptional possible composeOptional 
 possible composeLens schemaProperties composeLens at("lang") 
 composeOptional possible composeOptional possible composeLens 
 schemaPattern)
  .set(Option("Our language code regex here!"))(docs)
```

The modification for the `Translation` model looks quite the same so we could possibly make a function out of it which would get some parameters and return the updated structure.

Q> What are we missing?

Oh yeah, right we thought about extracting the regular expression directly from the refined type to avoid code duplication. So let's try to use the function defined earlier on like this `val langRegex = extractRegEx[LanguageCode]`.

```text
[error] : type arguments [com.wegtam.books.pfhais.tapir.models.LanguageCode] 
  do not conform to method extractRegEx's type parameter bounds [S <: String]
[error]     val langRegex = extractRegEx[LanguageCode]
[error]                                 ^
```

Okay, seems like I really don't understand what I'm doing. ;-) Luckily for us the Scala community has nice, smart and helpful people in it. The solution is to write a type class which will support us extracting the desired parameter.

{caption: "Type class to extract the regular expression"}
```scala
import eu.timepit.refined.api._
import eu.timepit.refined.string._
import shapeless.Witness

trait RefinedExtract[T] {
  def regex: String
}

object RefinedExtract {
  implicit def instance[T, S <: String](
      implicit ev: String Refined MatchesRegex[S] =:= T,
      ws: Witness.Aux[S]
  ): RefinedExtract[T] = new RefinedExtract[T] { val regex = ws.value }
}
```

This allows us to have the desired effect in just this small piece of code.

{caption: "Extract and transform regular expression from LanguageCode"}
```scala
val typeRegex = implicitly[RefinedExtract[LanguageCode]].regex
// convert to Javascript regular expression
val langRegex = "/" + typeRegex + "/"
```

Now if we take a look at our API documentation it looks better. Although we can see that the URL parameter pattern information is not used. But as mentioned before there is a lot of work going on at the tapir site currently and this will also get fixed then.

I> While I'm writing these lines the awesome tapir project has merged a pull-request which enables much easier customisation of derived schemas for documentation. :-)

However don't forget about optics because their usage goes far beyond what we have done here.

# Moving to Scala 3...

When I wrote this book version 2.12 was the thing and 2.13 was not yet released. While I did enable cross-building for 2.13 after it was released the next big version was still far away. But then it happened and Scala 3 was released. However it took some time until libraries and frameworks moved to support it. As I am writing this some still have not added support for it because in some areas this involves a significant amount of work.

However, I always wanted to do an update to Scala 3 and while I might still find time to write a complete book about that, I chose not to wait longer although some libraries I would like to use are still not ported. Therefore the topic of this chapter will be to update our small service (the tapir version) to Scala 3 while dropping some not yet ported libraries.

But instead of jumping right into the middle of it we might be better of to look at our options and plan our migration accordingly.

The first step should be to switch to Scala 2.13 as major version and update all dependencies to their latest versions. This alone will be quite some work but it will ease the migration to Scala 3 for which we will try to use some tools which are available.

Since version 1.5 the sbt build tool supports Scala 3 directly so there is no more need to add the sbt-dotty plugin to your build. Additionally it supports a new syntax for dependencies which will allow us to use 2.13 libraries in 3 and vice versa.

{caption: "Using Scala 2.13 libraries in Scala 3 projects"}
```text
libraryDependency +=
  ("my.domain" %% "my-lib" % "x.y.z").cross(CrossVersion.for3Use2_13)
```

The example above instructs sbt to use a Scala 2.13 library for Scala 3. If you want to do the opposite then you have to use `CrossVersion.for2_13Use3` instead which will make sbt use a Scala 3 library for Scala 2.13.

Furthermore there is the Scala-3-Migrate plugin for sbt which supports on a variety of topics when migration a project to Scala 3.

So the second step would be to use the Scala-3-Migrate plugin to guide our migration to Scala 3. During this phase we will see what can be kept, what can be used with some restrictions and what has to be dropped.

## Step 1: Updating to 2.13.x

The currently recommended version to start a migration from is 2.13.7 so we will target this Scala version for updating our project. In the source code you can see that I simply copied the `tapir` folder of our project and named it `tapir-scala-3` to not mess with our existing code.

First steps include updating sbt to a recent version as well as updating the sbt-plugins that we are using to their latest versions. Also some changes are made in regard to the compiler plugins. The kind-projector plugin needs a different way to be specififed (see `cross CrossVersion.full` in `build.sbt`) and the monadic-for plugin stays for now but will have to be removed when we're on Scala 3. And while at it the migration plugin to support us is added as well:

{caption: "Add the scala3-migrate plugin to sbt"}
```
addSbtPlugin("ch.epfl.scala" % "sbt-scala3-migrate" % "0.5.0")
```

Now we switch the default version for Scala to `2.13.7` and try to compile the project. We run into some missing dependencies errors which will force our hand into upgrading several dependencies. In addition we stumble upon the matter that the compiler flag `-Xlint:nullary-override` has been dropped so we remove it or comment it out.

I> As much as I like it to turn any warning into an error, for a migration like this I recommend to fix only the deprecation issues and then turn off the `Xfatal-warnings` flag.

Furthermore to reduce the clutter in our build file we remove support for Scala 2.12 and the related compiler options. In the case that you have to support older versions of Scala (cross compilation) things get more complicated. In our case we can move completely to Scala 3. :-)

### Details and some compiling issues

So what was done until now?

1. include kind-projector plugin via CrossVersion.full
2. switch to Scala 2.13.7 aus default version
3. remove Scala 2.12 and related settings
4. update doobie to 0.8.8
5. update http4s to 0.21.31
6. update tapir to 0.11.11
7. update circe to 0.14.1
8. remove dropped compiler flags (for 2.13!)
9. disable `Xfatal-warnings`

So far compiling our main code resulted in nagging us to fix several issues with auto-application of missing brackets for function calls, the main culprit being `unsafeRunSync` here which has to be `unsafeRunSync()`. Also some unused variable issues were popping up and are fixed easily too.

Now onwards to compiling the tests and we have some more issues. So far the integration tests compile fine but the unit tests spill out an error:

{caption: "Compiler errors in the tests"}
```text
[error] .../TestRepository.scala:26:51: trait Seq takes type parameters
[error]         val ns = p.names.toNonEmptyList.toList.to[Seq]
[error]                                                   ^
[error] .../TestRepository.scala:26:50: missing argument list for method to 
          in trait IterableOnceOps
[error] Unapplied methods are only converted to functions when a function type
          is expected.
[error] You can make this conversion explicit by writing `to _` or `to(_)`
          instead of `to`.
[error]         val ns = p.names.toNonEmptyList.toList.to[Seq]
[error]                                                  ^
[error] .../TestRepository.scala:32:49: trait Seq takes type parameters
[error]       val ns = p.names.toNonEmptyList.toList.to[Seq]
[error]                                                 ^
[error] .../TestRepository.scala:32:48: missing argument list for method to
          in trait IterableOnceOps
[error] Unapplied methods are only converted to functions when a function type
          is expected.
[error] You can make this conversion explicit by writing `to _` or `to(_)`
          instead of `to`.
[error]       val ns = p.names.toNonEmptyList.toList.to[Seq]
[error]                                                ^
[error] four errors found
```

This looks big at first but let us stay calm an read the error messages. So the "trait Seq takes takes type parameters" eh? The second one says something about "unapplied methods" but isn't exactly helpful either.

Q> What can we do?

Well, we fire up a REPL of course and as we are (or should be) in sbt we can simply use the `console` command. The sbt console will only work if we fixed all our compilation errors in the main code.

{caption: "Check for possible function for converting List"}
```scala
scala> List(1, 2, 3).to<TAB>
// This should show a list of possible functions.
```

So it seems we are missing our plain old (`.to[T]`). While there is a `.to()` function it requires a collection factory. So what about `.toSeq`? We did not use it in the past because it converted into a mutable sequence. But what about now?

{caption: "Test List conversion in the REPL"}
```scala
scala> val a: scala.collection.immutable.Seq[Int] = List(1, 2, 3).toSeq
val a: Seq[Int] = List(1, 2, 3)
scala> a.getClass
val res0: Class[_ <: Seq[Int]] = class scala.collection.immutable.$colon$colon

scala> a.getClass.getCanonicalName
val res1: String = scala.collection.immutable.$colon$colon

scala> a.getClass.getName
val res2: String = scala.collection.immutable.$colon$colon
```

Well, well this looks pretty good I'd say so let's adjust the code. And quickly we get a big type error but the gist of it is:

{caption: "Compiler error about invariant types"}
```text
[error] Note: List[...] <: Seq[...], but type F is invariant in type _.
[error] You may wish to define _$$1 as +_$$1 instead. (SLS 4.5)
[error]         ns.map(n => (p.id, n.lang, n.name)).pure[F]
[error]                                                 ^
[error] one error found
```

Good news first: The original error is gone and we can even simplify the code around the second error source by removing the `toSeq` completely. But the remaining one is heavier. So let's take a step back and take a deep breathe. If we take a look at our function signature we can see that it requires a `Seq` but what if we simply change it to `List`?

So let us try it and see how far we get. First we have to change the type signature of the function `loadProduct` in `Repository` to have a `List` instead of a `Seq` in its return type. Afterwards the compiler will tell us exactly in which places we have to make changes. Furthermore we can also remove some imports (`scala.collection.immutable.Seq`) which are no longer needed.

Okay, onwards to... Did you run the tests? ;-)

While executing the tests we discover that some unit tests are failing and the integration tests look good. Additionally I get a warning that the Flyway library should be updated. But we save this for later. Let us take a look at our failing tests first. We can see that they error out because of an exception:

{caption: "The dreaded NoSuchMethodError after a dependency upgrade"}
```text
java.lang.NoSuchMethodError: 'cats.data.Kleisli
  org.http4s.HttpRoutes$.apply(scala.Function1, cats.effect.Sync)'
```

This does not look good and it seems to be not caught by the compiler. We should start our service to see if it happens there too. So after a `sbt run` we can see that it affects our main code also.

Nice we just broke our service. Welcome to the world of software development! :-)

Q> So what could be the root cause here?

Most likely we are in trouble due to updating dependencies and running into some binary incompatibility issues. The error message indicates that it might either be cats or http4s related. To get some more insights we should issue the `sbt evicted` command and take a look at the output. We find some messages about replaced versions.

{caption: "Output snippets from the sbt evicted command"}
```text
* org.http4s:http4s-dsl_2.13:0.21.31 is selected over 0.21.0-M5
...
* org.typelevel:cats-effect_2.13:2.5.1 is selected over {2.0.0, ...}
...
* org.typelevel:cats-core_2.13:2.6.1 is selected over {2.0.0, ...}
...
* org.http4s:http4s-blaze-server_2.13:0.21.31 is selected over 0.21.0-M5
...
```

Now we need to perform some investigations regarding the libraries which means digging into changelog entries, release notes and bug reports which might support our idea of something was broken. The cats part of the equation looks fine but there were some changes in the http4s library which might be the cause for our problem here. As the older version (`0.21.0-M5`) is a pre-release this is something that is totally valid and should always be on our radar. The older version is a dependency of tapir so that means we have to upgrade tapir as well which means "More breaking changes, yeah!" ;-)

I> The more you run into problems when updating your applications the more you come to understand the restraint to updates. But if your application is still actively maintained then updates are a part of life and regular updates save you the pain of doing a major one every couple of years.

But before we tackle this problem we might as well quickly update the Flyway library to get rid of the warning in our tests. Brave as we are we jump to the most recent release and also update the driver for PostgreSQL as well. But what is this?

{caption: "Type error after Flyway upgrade"}
```text
[error] .../FlywayDatabaseMigrator.scala:35:21: type mismatch;
[error]  found   : org.flywaydb.core.api.output.MigrateResult
[error]  required: Int
[error]       flyway.migrate()
[error]                     ^
[info] org.flywaydb.core.api.output.MigrateResult <: Int?
[info] false
[error] one error found
```

You didn't expect this to be easy, did you? ;-) But this doesn't look like a big issue. The return type of the migrate function was changed upstream and the only decision we have to make is if we want to change our function return type accordingly and simply pass the information onwards or do we change the function a bit and still only return the number of applied migrations. I pick the lazy route this time and simply append `.migrationsExecuted` to the call to `.migrate()` and we're done with it.

Now onwards to our tapir update. Before we simply upgrade to the latest version we should give it some more thought. Tapir is still in a heavy development phase and might depend on pre-release versions of other libraries again. So we better look some things up. The file `project/Versions.scala` within the tapir source repository gives us our needed insights. If we do not want to upgrade http4s even higher then it seems we will have to pick a tapir 0.17.x release. Such a jump will likely include lots of breaking changes so another option would be to pick the lowest possible tapir release with a compatible http4s dependency.

Q> So what are our options?

We can either upgrade to the highest tapir version with a still compatible http4s dependency. Or we try to do the "minimum viable upgrade" and pick the lowest possible tapir version with a compatible http4s dependency to reduce our changes to a minimum. Last but not least we have the option to upgrade to the latest tapir version and upgrade all other dependencies as well.

The last option might be tempting but it will force us to upgrade not only http4s but other dependencies as well and we will likely head straight into "upgrade dependency hell" and may not even succeed.

Of our other options we can pick either the version 0.17.20 or something from the 0.12.x line of the tapir releases. Please not that the artefact organization name for tapir has changed! If you simply change the version number you will get unresolved dependency errors.

Upgrading software is not for the faint hearted so let's be brave and try to update to 0.17.20. The line between bravery and stupidity is a bit hazy but we'll see how we do. :-)

The first thing we stumble upon is of course a ton of errors because the namespace for tapir changed. Because changing it is simple but tedious it screams for automation and therefore we'll use a shell script[^41].

{caption: "Shell script to fix import namespace errors"}
```sh
% for i in `find tapir-scala-3 -name "*.scala"`; do
%   sed -i '' -e s/'import tapir'/'import sttp.tapir'/g $i
% done
```

This script is specific to the `sed` version used in the BSD operating systems! It is a simple loop being fed from a `find` command and uses `sed` to perform a search and replace operation directly in the file. The `-i ''` parameter ensures that no backup is saved (We are within in version control anyway.).

Okay after fixing that and the change of `StatusCode` and `StatusCodes` from tapir to sttp we still get a log of errors which look quite intimidating. Deciding that bravery is all good and so we turn to plan B switching the tapir version to 0.12.28. ;-)

We still get a bunch of errors now but they are less in number and seem mostly related to schema creation and derivation. Also not the most easy topic but as we get the same errors on 0.17.x plus a load more we might as well try to fix them. The first guess is that some code has been moved and indeed it seems that our `Schema.SWhatever` types are now under `SchemaType.SWhatever` so this should be fixed easily. Additionally we need to do small adjustments regarding changed signatures and use `Schema(SchemaType.SWhatever)` instead of `Schema.SWhatever` in some places.

{caption: "Total error count so far"}
```text
...
[warn] two warnings found
[error] 6 errors found
```

Nice! We are down to a single digit number of errors. It looks like I didn't fix the `StatusCodes` issue correctly so after some changes we are down to one error:

{caption: "Last remaining compiler error after the tapir upgrade"}
```text
[error] .../ProductsRoutes.scala:117:54: not found: value tapir
[error] streamBody[Stream[F, Byte]](schemaFor[Byte], tapir.MediaType.Json())
[error]                                              ^
[error] one error found
```

After digging a bit through the tapir code we can see that we simply have to pass a `CodecFormat.Json()` here now. Hooray, it compiles! But before we become too confident, let us run some tests.

{caption: "All our tests passed"}
```text
[info] All tests passed.
```

This is good news and furthermore starting our service via `sbt run` looks good also. :-)

Now we could move on to the next step or we might try updating some more dependencies. For starters we remove the wartremover plugin because it isn't available for Scala 3 anyway. Besides the plugin we must remove the settings in the `build.sbt` and the annotations within the code (see the `@SuppressWarnings` annotations). As a bonus we get rid of some warnings about `Any` type inference which are false positives anyway. Next is the move to the Ember server for http4s from the Blaze one because Ember is the new default and recommended one. For this our main entry point in `Tapir.scala` has to be adjusted a bit.

First we change from `IOApp` to `IOApp.WithContext` and implement the `executionContextResource` function. In addition we adjust our blocking thread pool to use 2 threads or half of the available processors.

{caption: "Adjustments in the main entry point"}
```scala
object Tapir extends IOApp.WithContext {
  val availableProcessors: Int =
    Runtime.getRuntime().availableProcessors() / 2
  val blockingCores: Int =
    if (availableProcessors < 2) 2 else availableProcessors
  val blockingPool: ExecutorService =
    Executors.newFixedThreadPool(blockingCores)
  val ec: ExecutionContext =
    ExecutionContext.global

  override protected def executionContextResource: 
    Resource[SyncIO, ExecutionContext] = Resource.eval(SyncIO(ec))

  def run(args: List[String]): IO[ExitCode] = {
    val blocker = Blocker.liftExecutorService(blockingPool)
    val migrator: DatabaseMigrator[IO] = new FlywayDatabaseMigrator
    // ...
      resource = EmberServerBuilder
        .default[IO]
        .withBlocker(blocker)
        .withHost(apiConfig.host)
        .withPort(apiConfig.port)
        .withHttpApp(httpApp)
        .build
      fiber = resource.use(_ => IO(StdIn.readLine())).as(ExitCode.Success)
    // ...
```

W> Please beware that the `availableProcessors` function might report wrong values if the JVM is running within a docker container!

The update of the refined library requires us to update pureconfig as well in one step but it just works after increasing the version numbers. The same can be said about logback, cats and kittens. For the latter we make some small adjustment to get rid of a deprecation warning.

Some more changes are required for updating ScalaTest and ScalaCheck but they boil down to changing some imports and names (i.e. `Matchers` instead of `MustMatchers`) and the inclusion of the ScalaTestPlus library which acts as a bridge to ScalaCheck now.

I> Note that we run tests and integration tests after each dependency update to be sure!

The things left to update look like they might be a bit more involving:

1. Doobie (database layer)
2. http4s (might not be that difficult as we switched to Ember already)
3. Monocle (version 3.x brings huge improvements but will require many changes)
4. tapir (contains breaking changes and might introduce more dependency trouble)

As mentioned before we shouldn't simply dive in but check what is really needed. To gather the necessary information we move on to the next step.

## Step 2: Migrating to Scala 3

We have prepared our battle ground and already included the sbt plugin so we can just issue the `migrate-libs tapir` command to get some output. This is quite a lot so let's concentrate on the important parts. First there is some explanation on the top:

{caption: "Possible status flags for dependencies for Scala 3 migration"}
```text
[info] X             : Cannot be updated to scala 3
[info] Valid         : Already a valid version for Scala 3
[info] To be updated : Need to be updated to the following version
```

We should not see the `X` mark (usually red in the terminal) but here we are and I count two of them. So what do we have?

1. The better-monadic-for plugin.
2. The pureconfig library.

The first one is no problem because we can simply drop it and the underlying problem is supposed to be solved in Scala 3. But what about pureconfig? Well let's worry later and process the output further. We have quite some `Valid` marks which is great! Several others have other notes on them so onward to take a closer look.

The following dependencies are supposed to work with `CrossVersion.for3Use2_13`:

1. Monocle
2. Refined

Last but not least some dependencies need to be updated further to support Scala 3:

1. Doobie
2. http4s
3. kittens
4. tapir

So it looks like we won't get away without doing major upgrades anyway. While at it we might as well add Monocle to our upgrade list because it looks like it will be quite some work either way.

The attentive reader will have noted that the recommended dependency updates have pre-release version numbers and she'll ask if we really should upgrade them or wait until proper releases have been published. And yes, she is right: Though shall not use pre-release software in production!

For our example here however we do it for demonstrating the upgrade process. In production I would advise you to wait or maybe upgrade and test in a separate environment.

Q> But where to start?

So, tapir has dependencies on http4s and also cats-effect therefore it will surely influence http4s and also doobie which also uses cats-effect. So the first candidate should be kittens because it doesn't affect the other dependencies. The next one will be Monocle because although *maybe* not necessary it also doesn't mess up the other dependencies. While updating kittens is done by simply increasing the version number the Monocle part will likely be more involving. After increasing the version number for Monocle and changing also the artefact group and removing the laws package we are greeted by a number of deprecation warnings and one errors upon compilation. This doesn't look too bad so maybe we are lucky after all, are we?

For the deprecations there is an open issue for providing Scalafix rules for automatic code rewrite but it is not yet done[^42] therefore we have to do it ourselves. But at the issue we find a nice list of deprecated methods and their replacements! As for the error message:

{caption: "Compiler error related to Monocle"}
```text
[error] .../Tapir.scala:117:11: object creation impossible.
        Missing implementation for:
[error]   def modifyA[F[_]](f: V => F[V])
            (s: scala.collection.immutable.ListMap[K,V])
            (implicit evidence$1: cats.Applicative[F]):
            F[scala.collection.immutable.ListMap[K,V]]
            // inherited from trait PTraversal
[error]       new Traversal[ListMap[K, V], V] {
[error]           ^
```

This might look intimidating but actually it is just complaining about a missing implementation so we will have to adjust or rewrite the one we are providing. But wait! Didn't we provide patches to Monocle for the missing instances for `ListMap`? Yes we did! So how about removing our custom instances?

{caption: "Monocle error is gone and only warnings remain"}
```text
[warn] 62 warnings found
[success] ...
```

Nice! Always remember: It pays off to provide your custom extensions and patches upstream!

However now we get a lot of errors if we try to compile our tests. So we need to investigate. But before we do that let's fix all these deprecation warnings to get our code clean. Some things are pretty trivial but if we remove the `possible` command which has no replacement then our code does not compile any longer. We could just ignore it because it is a warning but it is a deprecation one therefore it definitely *will* come back later to bite us. However we ignore it for now and look at our weird compile error in the tests.

{caption: "Weird error after upgrading another dependency"}
```text
[error] ... object scalatestplus is not a member of package org
```

This is strange not only because Monocle has no apparent connection to our testing libraries. But doing our research we find an issue in the bugtracker of scalatestplus[^43] and applying the workaround from there (manually including a dependency to discipline-scalatest) solves our issue. Hooray! But to be honest: I have no idea what is going on behind the scenes here. Likely some dependency issues which cannot be resolved and are silently dropped or so. While we're at it we simply upgrade our Scala version to 2.13.8.

Ignoring the remaining deprecation warnings our tests are running fine and we take another look at the output of `migrate-libs tapir` within sbt. It seems we have to at least upgrade to tapir 0.18.x. The current stable version being 0.19.x we can see that it depends on http4s 0.23.x which in turn depends on cats-effect 3. Being a major rewrite version 3 of cats-effect will clash with our doobie version. So we will have to switch to the current pre-release version of it. But at least it is close to being released. :-)

Because the dependencies are so much weaved together we have no choice but to update them all in one step. We won't have compiling code either way and will likely get misleading error messages if we do them step by step. So let's increase some version numbers, take a deep breath and parse some compiler errors. To summarise: We update doobie to 1.0.0-RC2, http4s to 0.23.10 and tapir to 0.19.4. Additionally we have to adjust the tapir swagger ui package because some packaging changed.

{caption: "Total error count in the main code after major upgrades"}
```text
[warn] 5 warnings found
[error] 33 errors found
[error] (Compile / compileIncremental) Compilation failed
```

Okay, that doesn't look too bad. Remember, we fixed similar numbers already. But where to start?

One of the libraries in the background that all others are using is cats-effect so maybe we should start with that one. Reading the migration guide we realise that there is a Scalafix migration which we could use for automatic conversion of our code. But it says: "Remember to run it *before* making any changes to your dependencies' versions." ;-)

So then let us rollback our versions and take a stab at the migration to cats effect 3 via Scalafix. The guide to manually applying the migration is straightforward however the results are a bit underwhelming as nearly nothing is changed. But the migration guide has lots of additional information about changed type hierarchies and so on so we are not left in the dark. Therefore we re-apply our version upgrades again and go on fixing the compilation errors. For convenience we start at our main entry point which is in `Tapir.scala`.

Concentrating on cats-effect first we need to adjust our `IOApp.WithContext` into a simply `IOApp` (Basically reverting our changes from some pages back.) and can remove some code which is not needed any longer. Afterwards we have fixed some errors and the ones that still show up seem to be related to tapir and http4s. On the http4s side it seems that we now need a proper `Host` class instead of our non-empty string. So one option would be do to something like this:

{caption: "Possible solution for the configuration type problem"}
```scala
host <- IO(
  com.comcast.ip4s.Host
    .fromString(apiConfig.host)
    .getOrElse(throw new RuntimeException("Invalid hostname!"))
)
```

It will work but why do we have introduced properly typed configuration then? On the other hand we might have to drop pureconfig because the migrate plugin told us that there is no version of it for Scala 3 yet. However looking at the repository and bugtracker[^44] we can see that basic Scala 3 support is supposed to be there. So let's try to do it the proper way first!

While we're at it we realise that we also need a `Port` type also instead of custom `PortNumber` and of course pureconfig needs to be provided with type classes which can read these types.

{caption: "A cleaner solution for the configuration type problem"}
```scala
import com.comcast.ip4s.{ Host, Port }
import pureconfig._
import pureconfig.generic.semiauto._

final case class ApiConfig(host: Host, port: Port)

object ApiConfig {
  implicit val hostReader: ConfigReader[Host] =
    ConfigReader.fromStringOpt[Host](Host.fromString)
  implicit val portReader: ConfigReader[Port] =
    ConfigReader.fromStringOpt[Port](Port.fromString)

  implicit val configReader: ConfigReader[ApiConfig] =
    deriveReader[ApiConfig]
}
```

This is our new `ApiConfig` class (comments removed from the snippet) and it looks like it works because we have even less compiler errors now. :-)

However there is a new one now for the last part of our for comprehension returning the `fiber`:

{caption: "Cats effect related type error in the main entry point"}
```text
found   : cats.effect.IO[cats.effect.ExitCode]
required: cats.effect.ExitCode
```

This is fixed easily though by just changing the `fiber = ...` to `fiber <- ...` within the for comprehension. After that we take a look at the error we get from tapir. They are related to the swagger UI and API documentation stuff. Referring to the tapir documentation the changes are quite simple, we just change an import and the way we construct our documentation structure.

{caption: "Fix the swagger UI problems in the code"}
```scala
import sttp.tapir.swagger.SwaggerUI
//...
docs = OpenAPIDocsInterpreter().toOpenAPI(
  List(
    ProductRoutes.getProduct,
    ProductRoutes.updateProduct,
    ProductsRoutes.getProducts,
    ProductsRoutes.createProduct
  ),
  "Pure Tapir API",
  "1.0.0"
)
updatedDocs = updateDocumentation(docs)
docsRoutes  = Http4sServerInterpreter[IO]()
                .toRoutes(SwaggerUI[IO](updatedDocs.toYaml))
//...
httpApp     = Router("/" -> routes, "/docs" -> docsRoutes).orNotFound
```

Another step done, nice! Let's enjoy the moment and move on to the other errors which are in our optics part of the file where we define lenses on the `OpenAPI` structure of tapir which seems to have changed quite a lot. So for starters there is the `ReferenceOr` structure which simply moved to another place so we can just add an import and reference it directly instead of `OpenAPI.ReferenceOr` and some errors are gone. Others are about the internal structure for example we now get a `Paths` type instead of a `ListMap` on some attributes. But before we dive to deep into this one we might as well thing about refactoring our optics part a bit more because we basically kept our old approach and just changed it so far as to compile with the latest Monocle library. But what about actually utilising the shiny new features? ;-)

But let's save this for later because the really nice features are Scala 3 only. So we just stub our function out and make it simply return the parameter it receives to make it compile again.

{caption: "Workaround for the needed Monocle adjustments"}
```scala
private def updateDocumentation(docs: OpenAPI): OpenAPI = docs
```

Some of the errors left are related to tapir schemas so let's try them first because they are few and directly related to our data models. Instead of specifying everything manually we try the semi-automatic derivation this time. We soon realise that we still have to specify some instances but the code we need to make it compile looks cleaner than the one before:

{caption: "Changes to the tapir schema definitions for our models"}
```scala
object Translation {
  //...
  implicit val schemaForLanguageCode: Schema[LanguageCode] =
    Schema.string
  implicit val schemaForProductName: Schema[ProductName] =
    Schema.string
  implicit val schemaFor: Schema[Translation] =
    Schema.derived[Translation]
}
object Product {
  //...
  implicit val schemaForProductId: Schema[ProductId] = Schema.string

  implicit def schemaForNeS[T](implicit a: Schema[T]):
    Schema[NonEmptySet[T]] = Schema(SchemaType.SArray(a)(_.toIterable))

  implicit val schemaFor: Schema[Product] = Schema.derived[Product]
}
```

So far so good. If we really nailed it we will only know later when it might blow up in our faces or not. ;-)

Further on we need to replace the `Sync` type in our routing classes with `Async` to fix two more errors. The route creation changed so we have to use a `Http4sServerInterpreter[F]().toRoutes(...)` function now to create our routes. It still gives some errors but let's look at our endpoint definitions first. The type signature for endpoints changes from `[I, E, O, S]` to `[A, I, E, O, R]`. Sorry for the abbreviation overkill here. The details can be looked up at the tapir docs but the gist is that we have an additional type ("security input") at the start and instead of the "streaming type" we have a "capabilities type" now at the end. Because we don't use the security input type we can set it to `Unit` or could also use the `PublicEndpoint` type alias which is provided by tapir. In the case of streaming endpoints the output type stays as before (`Stream[F, Byte]`) and the capabilities type at the end becomes `Fs2Streams[F]` or `Any` for all non streaming endpoints.

For our streaming endpoint (`getProducts`) we get an error about the `streamBody` specification so we can adjust that one or replace it with the new `streamTextBody` directive. Both ways should work.

{caption: "Adjust the stream return type for our tapir endpoint"}
```scala
streamTextBody(Fs2Streams[F])(CodecFormat.Json(),
  Option(StandardCharsets.UTF_8))
```

We are down to a single digit number of compiler errors for our main code. This looks not bad so let's head on. The main issue now seems to stem from the `toRoutes` functionality.

{caption: "Type errors about the toRoutes function from tapir"}
```text
[error] overloaded method toRoutes with alternatives:
[error]   (serverEndpoints: List[sttp.tapir.server.ServerEndpoint[
            sttp.capabilities.fs2.Fs2Streams[F],F]])
              org.http4s.HttpRoutes[F] <and>
[error]   (se: sttp.tapir.server.ServerEndpoint[
            sttp.capabilities.fs2.Fs2Streams[F],F])
              org.http4s.HttpRoutes[F]
[error]  cannot be applied to (sttp.tapir.Endpoint[
           Unit,ProductId,StatusCode,Product,Any])
[error]     Http4sServerInterpreter[F]().toRoutes(...) { id =>
[error]                                  ^
```

For me this looks like the function will only accept streaming endpoints which doesn't make sense and would have surely been mentioned in the documentation or some release notes of the tapir project. But we take a closer look and we see that it actually expects `ServerEndpoint` instances here, not `Endpoint` ones. Or to quote from the documentation:

*To interpret a single endpoint, or multiple endpoints as a server, the endpoint descriptions must be coupled with functions which implement the server logic. The shape of these functions must match the types of the inputs and outputs of the endpoint.*

So server logic is added to an endpoint via one of the functions starting with `serverLogic` of course. ;-)

For our purpose we will use the default one (simply `serverLogic`). Let's test it out on one route:

{caption: "Fix the toRoutes errors using the serverLogic functionality"}
```scala
final class ProductRoutes[F[_]: Async] ... {
  //...
  private val getRoute: HttpRoutes[F] =
    Http4sServerInterpreter[F]().toRoutes(ProductRoutes.getProduct
      .serverLogic { id =>
        for {
          rows <- repo.loadProduct(id)
          resp = Product
            .fromDatabase(rows)
            .fold(StatusCode.NotFound.asLeft[Product])(_.asRight[StatusCode])
        } yield resp
      })

  private val updateRoute: HttpRoutes[F] =
    Http4sServerInterpreter[F]().toRoutes(ProductRoutes.updateProduct
      .serverLogic {
        case (_, p) =>
          for {
            cnt <- repo.updateProduct(p)
            res = cnt match {
              case 0 => StatusCode.NotFound.asLeft[Unit]
              case _ => ().asRight[StatusCode]
            }
          } yield res
      })
  //...
}
```

And it compiles fine! So we just need to move our logic into the `serverLogic` function part and we are set. Pretty cool but once we fix it we get another error from our main entry point:

{caption: "A new error from our main entry point"}
```text
Tapir.scala:42:26: method executionContextResource overrides nothing
```

However we can simply remove it and are done. Oh wait! We are skipped two things: first there is still the optics implementation left and second we want to fix this `example` problem in the one endpoint definition. Besides that we also get a lot of compilation errors for our tests. We turn there first an can very quickly fix our integration tests by removing the no longer used `IO.contextShift` from our `DoobieRepositoryTest` and by providing an implicit `IORuntime` within our `BaseSpec` class.

It turns out that for our regular tests we can apply the same fix to the `BaseSpec` there and also remove some obsolete code and adjust our imports because the http4s library has now a type called `ProductId` which clashes with our own one. After changing the `Effect` type in our `TestRepository` to `Async` the only thing left seems to be the ScalaCheck generators for our `ApiConfig` but these are also fixed easily.

So we fixed the compilation errors in our tests, but alas some tests are failing. :-(

At least the integration tests look fine, so let's take a look at the possible reasons for our failing tests. The failing ones are: `ApiConfigTest`, `ProductRoutesTest` and `ProductsRoutesTest`. The first one spills out the following message:

{caption: "Equality issue causing a failing test"}
```text
ApiConfig(127.0.0.1,34019) was not equal to ApiConfig(127.0.0.1,34019)
```

I don't know about you dear reader but I have stumbled into equality issues frequently (not *always* though but regular) so this should be resolvable by changing the `c must be(expected)` line in the test.

{caption: "Fix for the equality issue in the ApiConfig test"}
```scala
ConfigSource.fromConfig(config).at("api").load[ApiConfig] match {
  case Left(e)  => fail(s"Parsing a valid configuration must succeed! ($e)")
  case Right(c) => withClue("Config must be equal!")(c === expected)
}
```

In addition we add an implicit instance for the `Eq` of cats into the companion object of the `ApiConfig` class.

{caption: "Instance for cats Eq and ApiConfig"}
```scala
implicit val eqApiConfig: Eq[ApiConfig] = Eq.instance { (a, b) =>
  a.host === b.host && a.port === b.port
}
```

This fixes it and we can turn to the two remaining one. We soon find that the error message returned by tapir (which we check in the tests) has changed and is now more detailed so we simply adjust the according line in both tests and we are done here.

Nice, we have a compiling project again and if ignore our stubbed out Monocle function for now the `migrate-libs` task output some good looking results. So we execute the `migrate-scalacOptions` task next and take a look at the results. It uses the same notifications like the `migrate-libs` task to highlight problems. So far we have a couple of flags that the plugin could not recognize, quite a lot which are not valid any longer and some which we can use or have to rename.

First we change our `compilerSettings` function and add a case for Scala 3.

{caption: "Compiler settings for Scala 3 in build.sbt"}
```scala
//...
case Some((3, _)) =>
  Seq(
    "-deprecation",
    "-explain-types",
    "-feature",
    "-language:higherKinds",
    "-unchecked",
    //"-Xfatal-warnings", // Disable for migration
    "-Ycheck-init",
    "-Ykind-projector"
  )
//...
```

Also we add a `libraryDependencies` setting into our `commonSettings` block to only activate plugins for Scala 2.

{caption: "Load compiler plugins only for Scala 2 in build.sbt"}
```scala
//...
libraryDependencies ++= (
  if (scalaVersion.value.startsWith("2")) {
    Seq(
      compilerPlugin("com.olegpy"    %% "better-monadic-for" % "0.3.1"),
      compilerPlugin("org.typelevel" % "kind-projector"      % "0.13.2" cross CrossVersion.full)
    )
  } else {
    Seq()
  }
),
//...
```

Next is settings some flags for dependencies of which we want the 2.13 version.

{caption: "Using the 2.13 version for some dependencies in build.sbt"}
```scala
library.pureConfig.cross(CrossVersion.for3Use2_13),
library.refinedCats.cross(CrossVersion.for3Use2_13),
library.refinedCore.cross(CrossVersion.for3Use2_13),
library.refinedPureConfig.cross(CrossVersion.for3Use2_13),
```

Last but not least the big topic "new syntax" is lurking around the corner. But we will first add two more compiler flags which should make our 2.13 code compile in Scala 3 and add Scala 3 to the `crossScalaVersions` setting.

{caption: "Two migration compiler flags and the 3 version in build.sbt"}
```scala
//...
case Some((3, _)) =>
  Seq(
    "-deprecation",
    "-explain-types",
    "-feature",
    "-language:higherKinds",
    "-unchecked",
    //"-Xfatal-warnings", // Disable for migration
    "-Ycheck-init",
    "-Ykind-projector",
    // Gives warnings instead of errors on most syntax changes.
    "-source:3.0-migration",
    // Resolve warnings via the compiler of possible.
    "-rewrite",
  )
//..
crossScalaVersions := Seq(scalaVersion.value, "3.1.1"),
//...
```

Time for a first test run! We switch to Scala 3 by using `++3.1.1` in the sbt shell and issue a `clean` followed by a `compile`. Please not that you should have reloaded or restarted your sbt instance before to make it reflect all of our changes.

{caption: "Errors about conflicting dependencies versions"}
```text
[error] Modules were resolved with conflicting cross-version suffixes in 
  ProjectRef(uri(".../tapir-scala-3/"), "tapir"):
[error]    org.scala-lang.modules:scala-xml _2.13, _3
[error]    org.typelevel:simulacrum-scalafix-annotations _3, _2.13
[error]    org.typelevel:cats-kernel _3, _2.13
[error]    eu.timepit:refined _2.13, _3
[error]    org.typelevel:cats-core _3, _2.13
[error] stack trace is suppressed; run last update for the full output
[error] (update) Conflicting cross-version suffixes in:
  org.scala-lang.modules:scala-xml,
  org.typelevel:simulacrum-scalafix-annotations,
  org.typelevel:cats-kernel,
  eu.timepit:refined,
  org.typelevel:cats-core
[error]
```

Looks like we have a problem here. The libraries that we include in the version for 2.13 depend on other which collide with transitive dependencies of others using Scala 3. Digging through the maven central we can see that there are artefacts published for Scala 3 for pureconfig and refined, so what about removing our cross version settings and try them directly?

We soon find out that the refined module for pureconfig is not available for Scala 3 and in addition it seems that the generic derivation module is also not there. :-(

Q> So what now?

We could call it a day and stick with Scala 2 for the time being. However maybe there is a strong need for an upgrade. A library which only works partially under Scala 2 or other reasons. So imagine that we refactor our service a bit by removing some dependencies and add some more boilerplate to make up for it. At first we could simply remove the `CrossVersion` settings and use only libraries which are released for Scala 3. This move leaves us with hundreds of compiler errors. Many of them seem to be related to refined.

Because we have to start *somewhere* we try to create our `ConfigReader` instances for pureconfig manually to avoid the dependency to the derivation module. Luckily there are some helpers like the `ConfigReader.forProductX` methods which make this quite easy.

{caption: "A manual constructed reader for pureconfig"}
```scala
implicit val configReader: ConfigReader[DatabaseConfig] =
  ConfigReader.forProduct4("driver", "url", "user", "pass")
    (DatabaseConfig(_, _, _, _))
```

The code compiles again (on 2.13!) and the tests are looking good. On Scala 3 we run again into the problem that the refined pureconfig module is not available. So we could either drop our beloved refined types or we write manual readers for them. In Scala 3 we could use the opaque type aliases[^45] to get more type safety but they are much less powerful than refined types. Well, we'll see how it goes, so at first we define companion objects for our refined types to gain some more functionality i.e. the `from` method to convert arbitrary types into refined ones.

{caption: "A companion object for a refined type providing more functionality"}
```scala
type DatabaseLogin = String Refined NonEmpty
object DatabaseLogin extends RefinedTypeOps[DatabaseLogin, String]
  with CatsRefinedTypeOpsSyntax
```

As you can see this is pretty simple, we don't even need to implement something ourselves. Getting the instances for `ConfigReader` looks pretty simple too.

{caption: "ConfigReader instances for refined types - Take 1"}
```scala
implicit val loginReader: ConfigReader[DatabaseLogin] =
  ConfigReader.fromStringOpt(s => DatabaseLogin.from(s).toOption)
implicit val passReader: ConfigReader[DatabasePassword] =
  ConfigReader.fromStringOpt(s => DatabasePassword.from(s).toOption)
implicit val urlReader: ConfigReader[DatabaseUrl] =
  ConfigReader.fromStringOpt(s => DatabaseUrl.from(s).toOption)
```

But wait we get the dreaded "ambiguous implicit values" compiler error now. Since our types are all refined from `String` under the hood, the compiler throws an error at us.

Q> Can we solve it in a more general way?

Well, it seems that we don't need to because the pureconfig module of refined is a thing. But we cannot use it as it is because the usage of reflection is a no-go with Scala 3. But we can try to copy the base function and make some adjustments.

{caption: "Copied and adjusted converter function from refined-pureconfig"}
```scala
implicit def refTypeConfigConvert[F[_, _], T, P](
    implicit configConvert: ConfigConvert[T],
    refType: RefType[F],
    validate: Validate[T, P]
): ConfigConvert[F[T, P]] =
  new ConfigConvert[F[T, P]] {
    override def from(cur: ConfigCursor): ConfigReader.Result[F[T, P]] =
      configConvert.from(cur) match {
        case Left(es) => Left(es)
        case Right(t) =>
          refType.refine[P](t) match {
            case Left(because) =>
              Left(
                ConfigReaderFailures(
                  ConvertFailure(
                    reason = CannotConvert(
                      value = cur.valueOpt.map(_.render()).getOrElse("none"),
                      toType = "a refined type",
                      because = because
                    ),
                    cur = cur
                  )
                )
              )
            case Right(refined) => Right(refined)
          }
      }
    override def to(t: F[T, P]): ConfigValue =
      configConvert.to(refType.unwrap(t))
  }
```

So we copied it and simply omitted the type tag stuff which is based on reflection. This way we loose some information for our error message but we gain a hopefully Scala 3 compatible refined type reader for pureconfig. Many thanks again at this point to Frank S. Thomas the creator of the wonderful refined library and all the contributors!

Good, let's switch to Scala 3 (`++3.1.1` in the sbt shell) and try a clean compile which will give us a lot of errors still. However first things first. We notice some refined related ones in the top and fix them. The notation changed and we finally can use literal types so there is no longer a need for this weird `W.andsoon.T` constructs.

After fixing them we get 266 errors. Oh why cruel fate? But looking at them we can see that a lot of them come from our `LanguageCodes` class. As we remember that due to macro issues several things are not there yet in libraries under Scala 3 we are again faced with the decision to abandon refined types or find yet another workaround. To keep this chapter from growing exponentially I'll pick the lazy (and dirty) workaround for this time. A simple nudge in your favourite editor should convert the code in the file to something like this:

{caption: "Workaround for missing refined macros"}
```scala
val all: Seq[LanguageCode] = Seq(
  LanguageCode.unsafeFrom("ad"),
  LanguageCode.unsafeFrom("ae"),
  LanguageCode.unsafeFrom("af"),
  //...
)
```

This is not the nicest solution but it leaves us with only 17 errors to fix and they look like they have the same cause. So after fixing the same thing in our routing examples we are down to one error:

```text
[error] -- [E008] Not Found Error: .../Tapir.scala:47:31
[error] 47 |      (apiConfig, dbConfig) <- IO {
[error]    |                               ^
[error]    |value withFilter is not a member of 
[error]    |  cats.effect.IO[(com.wegtam.books.pfhais.tapir.config.ApiConfig,
[error]    |  com.wegtam.books.pfhais.tapir.config.DatabaseConfig
[error]    |)]
[error] one error found
[error] one error found
```

Well the only time I got that one was when I removed the better-monadic-for compiler plugin and it won't be available for Scala 3 because it shouldn't be needed. But we can solve it by de-composing our code into several chunks.

{caption: "Fixing the withFilter error in Tapir.scala"}
```scala
for {
  cfg       <- IO(ConfigFactory.load(getClass().getClassLoader()))
  apiConfig <- IO(ConfigSource.fromConfig(cfg).at("api")
    .loadOrThrow[ApiConfig])
  dbConfig  <- IO(ConfigSource.fromConfig(cfg).at("database")
    .loadOrThrow[DatabaseConfig])
  //...
```

Awesome! We have our main code compiling under Scala 3 now! =)

Compiling the tests suites greets us with a couple of errors though, so no celebrations just yet. Some of them are refined related like in the main code (missing macros) so we will apply our `unsafeFrom` workaround for them and get rid of them. Then we have an error about implicit values needing an explicit type which is a good practice anyway. The integration tests look similar and are easy to fix too. However we have two failing tests after compilation. One within each route test and both related to checking the some error response for malformed requests. So we simply adjust the error message we test for and we are done.

I> We have a completely compiling project with green tests under Scala 3 now!

This is awesome but according to the official migration guide we should also try to migrate our syntax. So let's run the `migrate-syntax tapir` command in the sbt shell.

{caption: "Result of the migrate-syntax command"}
```text
[info]
[info] The syntax incompatibilities have been fixed in tapir / Test
[info]
[info]
[info] You can now commit the change!
[info] Then you can run the next command:
[info]
[info] migrate tapir
[info]
[info]
```

Looking at the source we can see that only some annotations have been added. And finally we run `migrate tapir` and it bails out with an error. I'll spare you the gory details but I did not have any clue about what was going wrong. But we know that everything is fine under Scala 3 anyway. So what about simply ignoring the tools lamentations and move on with our lives? Sounds good? Yeah, to me too. :-)

Before calling it a day we should switch back to 2.13 and do a clean compile to see some unused imports warnings be printed out. These are easy to fix and cleaner code is easier to maintain. Finally we adjust our `build.sbt` to make the switch permanent.

{caption: "Switch to Scala 3 by default"}
```scala
  //...
  scalaVersion := "3.1.1",
  crossScalaVersions := Seq(scalaVersion.value),
  //...
```

We can also remove some code related to Scala 2 (plugins and compiler settings).

Q> So what is left to do?

Well, we should change our scalafmt configuration because we surely do not want to get our shiny new Scala 3 code formatted according to Scala 2 syntax. ;-)

{caption: "A new configuration for scalafmt"}
```text
version        = 3.4.3
runner.dialect = scala3
style          = defaultWithAlign
# Other options...
danglingParentheses.preset = true
maxColumn                  = 120
newlines.forceBeforeMultilineAssign = def
project.excludeFilters     = [".*\\.sbt"]
rewrite.rules              = [Imports, RedundantBraces, RedundantParens]
rewrite.imports.sort       = ascii
rewriteTokens              = {
  ...
}
spaces.inImportCurlyBraces = true
unindentTopLevelOperators  = true
```

We used the opportunity to upgrade to the latest scalafmt and use a bit different settings. Running a `scalafmtAll` rewrites a lot of code, so we need to check if it still compiles. This looks fine so we are done, are we?

Q> So what is left to do?

Wait, we've been here before, haven't we? Hint: remember that `updateDocumentation` function using optics that we have stubbed out? Sometimes I wonder how many times smaller (or bigger) things get dropped under the table during such migrations only to be re-implemented later with great effort for new. We start with adding the needed import for the new Monocle (`import monocle.syntax.all._`) and try some things out. First we have this nice implicit extractor for the regular expression which defines our refined `LanguageCode` type. This one doesn't seem to work any longer. To keep things simple, we just write it down in the code.

Onwards to the `.focus` macro which is a killer feature of the new Monocle release. Instead of writing and combining all our custom `Lens` instances we should now be able to do something like the following:

{caption: "The Monocle focus in action"}
```scala
docs.focus(_.components.some.parameters.each.schema.pattern)
  .replace(uuidRegex.some)
```

Looks neat but we get an error that the function `components` is an overloaded one which seems is not supported. So it won't be that easy.

After poking around and asking for help (Please ask for help if you need it, there is absolutely nothing wrong with this.) we realise that we will have to generate lenses like before because the shiny focus macro cannot (yet) solve this for us. Sadly the `GenLens` macro also has problems with overloaded methods therefore we try to define `Getter` and `Setter` functionality for these manually. Some lenses can still be generated via `GenLens` like this `GenLens[Operation](_.parameters)` for example. For others we define code like the following:

{caption: "Manually define Getter and Setter"}
```scala
val componentsGetter = Getter[OpenAPI, Option[Components]](_.components)
val componentsSetter = Setter[OpenAPI, Option[Components]](
  f => o => o.copy(components = f(o.components))
)
```

However this is even more cumbersome than the manual macros before so maybe there is another way... And it turns out that we have another optics library for Scala which is called Quicklens[^46]. The fact that is comes from the same people that do the tapir project looks promising and indeed we do find a working implementation quickly.

{caption: "Using optics from Quicklens to update our documentation"}
```scala
private def updateDocumentation(docs: OpenAPI): OpenAPI = {
  // Our regular expressions.
  val langRegex = ???
  val uuidRegex = ???
  // Update the documentation structure.
  val updateProductId = docs
    .modify(_.paths.pathItems.at("/product/{id}").parameters.each
    .eachRight.schema.at.eachRight.pattern)
    .using(_ => uuidRegex.some)
  val updateModelProduct = updateProductId
    .modify(_.components.at.schemas.at("Product").eachRight
    .properties.at("id").eachRight.pattern)
    .using(_ => uuidRegex.some)
  val updateModelTranslation = updateModelProduct
    .modify(_.components.at.schemas.at("Translation").eachRight
    .properties.at("lang").eachRight.pattern)
    .using(_ => langRegex.some)
  updateModelTranslation
}
```

The `.modify` functionality looks very similar to `.focus` from Monocle and apart from the fact that the modifiers have different names we also do the same like in the Monocle code (*read* traverse through our structure). While Monocle would allow us to use more advanced features we are happy with Quicklens here because it fulfils our needs.

Q> So what is left to do?

Nothing! Go forth, ship your release and treat yourself for having ported your project to Scala 3. :-)

Of course I cheated because there is always something left like the not working `example` for one of our `ProductsRoutes` endpoints and furthermore: We have used package objects in our code which have been dropped in Scala 3. Therefore we should refactor these also. So feel free to do the required changes as a final exercise.

[^11]: http://slick.lightbend.com/doc/3.3.1/database.html

[^12]: https://pureconfig.github.io/

[^13]: https://typelevel.org/cats-effect/typeclasses/sync.html

[^14]: http://slick.lightbend.com/doc/3.3.1/sql.html

[^15]: https://blog.acolyer.org/2019/07/03/one-sql-to-rule-them-all/

[^16]: https://httpie.org/

[^17]: https://github.com/http4s/http4s/issues/2371

[^18]: https://www.wartremover.org/

[^19]: https://typelevel.org/cats-effect/datatypes/ioapp.html

[^20]: http://www.scalacheck.org/

[^21]: http://www.scalatest.org/user_guide/selecting_a_style

[^22]: https://rspec.info/

[^23]: https://github.com/scalatest/scalatest/issues/1370

[^24]: https://github.com/typelevel/kittens

[^25]: https://jmeter.apache.org/

[^26]: https://github.com/http4s/http4s/issues/2855

[^27]: https://swagger.io/

[^28]: https://swagger.io/tools/swagger-ui/

[^29]: https://swagger.io/tools/swagger-editor/

[^30]: https://github.com/swagger-akka-http/swagger-akka-http

[^31]: https://www.youtube.com/watch?v=snbsYyBS4Bs

[^32]: http://julienrf.github.io/endpoints/

[^33]: https://github.com/http4s/rho

[^34]: https://github.com/softwaremill/tapir

[^35]: https://www.servant.dev/

[^36]: https://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/poptics.pdf

[^37]: https://github.com/julien-truffaut/Monocle

[^38]: https://github.com/milessabin/shapeless

[^39]: https://tools.ietf.org/html/rfc4122

[^40]: https://www.ecma-international.org/ecma-262/5.1/#sec-7.8.5

[^41]: We could have used scalafix here but I consider this overkill for such a thing.

[^42]: https://github.com/optics-dev/Monocle/issues/1001

[^43]: https://github.com/scalatest/scalatestplus-scalacheck/issues/36

[^44]: https://github.com/pureconfig/pureconfig/issues/970

[^45]: https://docs.scala-lang.org/scala3/reference/other-new-features/opaques.html

[^46]: https://github.com/softwaremill/quicklens
